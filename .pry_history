cd FileUtils
show-method rm
.cat .vimrc
exit
gem list
exit
help
exit
help
s = "pry"
show-doc s.each_line
show-doc s.[]
show-doc String#[]
show-method String#[]
.pwd
.tree
def helo name
  show-input
  !
amend-line -h
.cd Projects
.pwd
.cd dm_app/dm_engine
.pwd
require "bundler/setup"
include DmEngine
require "dm_engine/entities/maxable_drug"
require "dm_engine/entities/drugs/maxable_drug"
ls MaxableDrug
ls MaxableDrug -m
ls MaxableDrug -M
ls MaxableDrug -Mj
edit-method MaxableDrug#restrict_to_max_daily_dose
edit MaxableDrug#restrict_to_max_daily_dose
? Array#select
ls Array
show-doc Array#select
show-doc String#[]
cd /
show-doc String#[]
s = "muppet"
show-doc s.[]
s = "pry"
show-doc s.each_line
exit
s = "pry"
show-doc s.each_line
exit
s = "pry"
show-doc s.each_line
whereami
show-doc s.each_line
? Array#select
exit
? Array#select
exit
.pwd
cd ..
.pwd
.cd ~/Projects/dm_app/dm_engine
.pwd
class Greater
  !
class Greeter
  def hello name
    puts "Hello, #{name}!"
  end
end
g = Greeter.new
g.hello "Jackson"
g.hello "Jackson";
hist
hist --replay 64..67
def bye name
  puts "Goodbye, #{name}!"
end
g.bye "Jackson"
exit
21/14
require "bigdecimal"
BigDecimal.new("21")/BigDecimal.new("14")
4 * (1/2)
4 * .5
4 * 0.5
nil.map { |o| p o }
Array(nil)
require "set"
Set.new.hash
[].hash
Array({ cat: "why", dog: "spook" })
exit
esit
exit
self
exit
self
exit
self
exit
self
schedule
max_daily_dose
exit
amount
self.amount
self.daily_dose
exit
self
new_schedule
schedule
max_daily_dose
schedule.restrict_daily_dose_to max_daily_dose
cd schedule
ls
? restrict_daily_dose_to
whereami 5
whereami(5)
show_method restrict_daily_dose_to
show-method restrict_daily_dose_to
exit
self
exit
self
new_schedule
new_schedule.dosings
exit
self
dosings
exit
self
dosings
self.schedule
self.schedule.dosings.first
self.schedule.dosings.first.unit
exit
? Array#select
require "bundler/setup"
include DmEngine
require "dm_engine/entities/exenatide"
require "dm_engine/entities/drugs/exenatide"
e = Exenatide.new
e.increment
load "dm_engine/entities/drugs/exenatide"
load "dm_engine/entities/drugs/exenatide.rb"
e.increment
BigDecimal.new("3") * (BigDecimal.new("1") / BigDecimal.new("3"))
(BigDecimal.new("3") * (BigDecimal.new("1") / BigDecimal.new("3"))).round(5)
(BigDecimal.new("3") * (BigDecimal.new("1") / BigDecimal.new("2"))).round(5)
(BigDecimal.new("3") * (BigDecimal.new("1") / BigDecimal.new("3"))).round(10)
load "dm_engine/entities/atomic_dose.rb"
atomic_three = AtomicDose.new amount: "3", unit: "foo"
require "dm_engine/entities/composite_dose"
load "dm_engine/entities/composite_dose.rb"
composite_four = CompositeDose.new atom_denomination: "2", number_of_atoms: 2, unit: "foo"
atomic_three + composite_four
BigDecimal.new("3") * (BigDecimal.new("1") / BigDecimal.new("3"))
atomic_three.class.methods
ls atomic_three -M
ls atomic_three.class -M
ls AtomicDose -M
ls Dose -Mj
ls Dose -mj
ls atomic_three.class -m
1.send :+
1.send :+, 2
1.send :+, 2, nil
1.send [:+, 2]
1.send *[:+, 2]
1.send *[:+, 2, nil]
1.send *[:+, 2, nil].compact
load "dm_engine/entities/drugs/drug.rb"
load "dm_engine/entities/drugs/incrementable_drugrb"
load "dm_engine/entities/drugs/incrementable_drug.rb"
Exenatide.new
load "dm_engine/entities/drugs/exenatide.rb"
Exenatide.new
load "dm_engine/entities/drugs/drug.rb"
Exenatide.new
exit
dosing_data
exit
dosing_data
exit
dosing_data
exit
dosing_data
exit
dosing_data
exit
dosing_data
exit
dosing_data
exit
dosing_data
exit
dosing_schedule
dosing_schedule.increment_dosings_by_dose_atom
new dosings_data: dosing_schedule.increment_dosings_by_dose_atom, max_daily_dose: Dose.build(amount: "20", unit: "mcg")
self.class.new dosings_data: dosing_schedule.increment_dosings_by_dose_atom, max_daily_dose: Dose.build(amount: "20", unit: "mcg")
ds = DosingSchedule.new Dosing.new(time: "time", atom_denomination: "1", number_of_atoms: 1, unit: "foo")
Drug.new dosing_data: ds
Drug.new dosings_data: ds
cd Drug
ls
show-method build_dosing_schedule_from
edit build_dosing_schedule_from
exit
Drug.new dosings_data: ds
edit Drug#build_dosing_schedule_from
Drug.new dosings_data: ds
ds.is_a? DosingSchedule
edit Drug#build_dosing_schedule_from
Drug.new dosings_data: ds
exit
dosing_data
self.class.initial_dosing_schedule
self.initial_dosing_schedule
initial_dosing_schedule
build_equivalent_composite_dose_from dosing_data
dose = build_equivalent_composite_dose_from dosing_data
Dosing.new time: dosing_data[:time],
atom_denomination: dose.atom_denomination,
number_of_atoms: dose.number_of_atoms,
unit: dose.unit
exit
dosing_data
exit
self
self.daily_dose
ls
self
show --help
help
ls --help
ls -i
ls -p
self
whereami
reload-method
self
exit
require "bundler/setup"
include DmEngine
require "dm_engine/entities/drugs/drug"
require "dm_engine/entities/drugs/exenatide"
require "dm_engine/entities/drugs/incrementable_drug"
Exenatide.new
BigDecimal.new("INFINITY")
h = { dog: "spook", cat: "why?" }
[h]
[[h]].flatten
[h].flatten
exit
require "dm_engine/entities/drugs/exenatide"
Exenatide.new dosings: { time: "time", amount: "5", unit: "mcg" }
include DmEngine
Exenatide.new dosings: { time: "time", amount: "5", unit: "mcg" }
Exenatide.new dosings: { time: "time", atom_denomination: "5", number_of_atoms: 1, unit: "mcg" }
one = Exenatide.new dosings: { time: "time", atom_denomination: "1", number_of_atoms: 2, unit: "mcg" }
two = Exenatide.new dosings: { time: "time", atom_denomination: "1", number_of_atoms: 2, unit: "mcg" }
three = Exenatide.new dosings: { time: "time", atom_denomination: "1", number_of_atoms: 3, unit: "mcg" }
two.increment_dosings_by_dose_atom
two.increment_dosings_by_dose_atom.amount.to_s
two.increment_dosings_by_dose_atom.daily_dose.amount.to_s
two.increment_dosings_by_dose_atom.daily_dose.amount
load "dm_engine/entities/drugs/liraglutide.rb"
Liraglutide.atom_denomination
Liraglutide.new dosings: { time: "time", atom_denomination: "1", number_of_atoms: 1, unit: "mg" }
load "dm_engine/entities/drugs/glp1_agonist_class_drug.rb"
exit
load "dm_engine/entities/drugs/liraglutide.rb"
load "dm_engine/entities/drugs/exenatide.rb"
Liraglutide.new dosings: { time: "time", atom_denomination: "1", number_of_atoms: 1, unit: "mg" }
include DmEngine
Liraglutide.new dosings: { time: "time", atom_denomination: "1", number_of_atoms: 1, unit: "mg" }
l = Liraglutide.new dosings: { time: "time", atom_denomination: "1", number_of_atoms: 1, unit: "mg" }
l.daily_dose
1/0.6
exit
include DmEngine
load "dm_engine/entities/drugs/exenatide.rb"
load "dm_engine/entities/drugs/liraglutide.rb"
l = Liraglutide.new dosings: { time: "time", atom_denomination: "1", number_of_atoms: 1, unit: "mg" }
l.daily_dose
require "big_decimal"
require "bigdecimal"
(1 / BigDecimal.new("0.6"))
(1 / BigDecimal.new("0.6")).round(5)
(1 / BigDecimal.new("0.6")) * BigDecimal.new("0.6")
(1 / BigDecimal.new("0.6") * BigDecimal.new("0.6"))
(1 / BigDecimal.new("0.6") * BigDecimal.new("0.6")).round(5)
(1 / BigDecimal.new("0.6") * BigDecimal.new("0.6")).round(10)
(1 / BigDecimal.new("0.6") * BigDecimal.new("0.6")).round(18)
(1 / BigDecimal.new("0.6") * BigDecimal.new("0.6")).round(1)
(1 / BigDecimal.new("0.6") * BigDecimal.new("0.6")).round(2)
exit
max_daily_dose
ls
cd ..
ls
exit
Drug
include DmEngine
Drug
require "bundler/setup"
require "dm_engine/entities/drugs/drug"
ls Drug
require "dm_engine/entities/drugs/incrementable_drug"
ls IncrementableDrug
require "dm_engine/entities/drugs/metformin_er"
ls MetforminER
IncrementableDrug.new
IncrementableDrug.new dosings: { time: "hs", amount: "1", unit: "mg" }, max_daily_dose: Dose.build(amount: "0", unit: "mg")
Math::INFINITY
Math.infinity
cd Math
ls
cd BigDecimal
ls
BigDecimal::INFINITY
BigDecimal.new("Infinity")
BigDecimal.new("infinity")
Rational(8/9) < BigDecimal::INFINITY
exit
r
exit
r
exit
type
instructions
drugs
type.hash ^ instructions.hash ^ drugs.hash
exit
continue_drugs
current_continue
current_continue.drugs
drug
Set[drug]
current_continue.drugs + Set[drug]
exit
drugs
exit
drugs
drugs.values
exit
drugs.values
drugs.values.any? { |drugs| include_drug? drug_list: drugs, name_string: name_string }
exit
down -h
up -h
help
up
wtf?
edit include_drug?
exit
ls
ls -i
ls -l
up
exit
!!@
ls -l
exit
ls -l
exit
ls -l
exit
ls -l
exit
ls -l
exit
ls -l
exit
ls -l
exit
ls -l
exit
ls -l
exit
ls -l
exit
ls -l
exit
require "dm_engine/entities/dose"
Dose::ZERO
include DmEngine
Dose::ZERO
p Dose::ZERO
ls IncrementableDrug
require "dm_engine/entities/drugs/incrementable_drug"
ls IncrementableDrug
Dose
Dose.build amount: "infinity", unit: "foo"
Dose.build amount: "Infinity", unit: "foo"
Dose.build amount: "INFINITY", unit: "foo"
Dose.build amount: "Infinity", unit: "foo"
["a", "b", "c"].length
["a", "b", "c"].size
show-method Array#length
show-method Array#size
show-method Array#count
Array(nil)
Array([])
require "set"
ls
Set["a", "b", "c"]
Set(Array("a"))
Set[Array("a")]
Set.new Array("a")
s = Set["a", "b", "c"]
pp s
pretty_print s
Dose.build amount: "Infinity", unit: "foo"
pp Dose.build amount: "Infinity", unit: "foo"
p Dose.build amount: "Infinity", unit: "foo"
pretty_print Dose.build amount: "Infinity", unit: "foo"
puts Dose.build amount: "Infinity", unit: "foo"
Set.new("a")
Set[]
Set.new(Set.new(["a"]))
Set.new([Set.new(["a"])])
Set[Set["a"]])
Set[Set["a"]]
require "dm_engine/entities/treatment"
ls Treatment
ls -a Treatment
Treatment.select
Treatment.choose
show-methods -m Treatment
show-methods -h
help
ls Treatment -m
ls Treatment -M
ls Treatment
Treatment.methods
Treatment.pretty_print_inspect
Treatment.methods.sort
Treatment.namespace_name
Treatment.new.namespace_name
$ Array.any?
$ Enumerable#any?
$ Array#any?
hash = { start_drugs: "start", stop_drugs: "stop" }
Treatment.new type: "foo", instructions: "bar", hash
Treatment.new(type: "foo", instructions: "bar", hash)
exit
!!!
help
gem-list
gem-cd minitest
gem-cd minitest-5.2.1
gem-cd minitest5.2.1
gem-cd minitest 5.2.1
gem-list
gem-cd minitest(5.2.1)
gem-cd minitest_5.2.1
gem-cd minitest-5.2.1
ls
exit
`ls
exit
s = "pry"
show-doc s.each_line
show-method String#each_line
$ String#each_line
cd String
$ each_line
cd each_line
up
down
self
def muppet name
  puts "#{name.title_case}, you muppet!"
end
muppet "jackson"
hist
show-methods String
self
show-methods String
exit
show-methods String
help
ls String
def muppet name
  puts "#{name.capitalize}, you muppet!"
end
muppet "jackson"
muppet "jackson";
gem-cd minitest
.pwd
.tree
.ls
.cd lib
.ls
.ruby -I test test/entities/test_dosing.rb
.pwd
self
.pwd
.cd ~
gem-cd minitest
reload
exit
gem-cd minitest
exit
help
exit-all
exit-program
gem-cd minitest
.pwd
exit
!!!
exit
require "bigdecimal"
gem-cd bigdecimal
BigDecimal.new "3"
exit
gem-cd minitest
exit
gem-cd minitest
exit
edit initialize
!!!
time
self.time
@time
@time = time
@time
self.time
Dosing.new
exit
time
self.time
exit
1.1r
1.2.to_i
2.9.to_i
show-method Float#to_i
-1.2.to_i
show-method Rational#to_i
show-method BigDecimal#to_i
require "bigdecimal"
show-method BigDecimal#to_i
show-method Rational#floor
1.2r.floor
$ Rational#floor
? Rational#floor
Rational(3, 2)
Rational(3, 2).floor
Rational(5, 2).floor
Rational(5, 2.floor(-1)
Rational(5, 2).floor(-1)
Rational(5, 2).floor(1)
Rational(5, 2).floor(2)
Rational::INFINITY
BigDecimal.new(Rational(3, 5))
BigDecimal.new(Rational(3, 5), 10)
1.hash
1r.hash
Rational(1, 3)
3.class
class J
  def initialize first:, second:, third: nil
    @first = first
    @second = second
    @third = third
  end
  attr_reader :first, :second, :third
end
J.new
exit
name
dosing_schedule
self
exit
self
name.hash
ls Fixnum
ls Rational
ls Rational -m
$ Rational#initialize
? Rational#initialize
Rational(1.2r)
1.2r
BigDecimal.new(1, 18)
BigDecimal.new(1, 20)
1 * 1r
exit
require "dm_engine/entities/dosing"
int = Dosing.new time: "quux", atom_denomination: 6, unit: "foo"
include DmEngine
int = Dosing.new time: "quux", atom_denomination: 6, unit: "foo"
rat = Dosing.new time: "quux", atom_denomination: 6r, unit: "foo"
Set[int] == Set[rat]
int == rat
$ Set.==
as = Set["a", "b", "c"]
bs = Set["a", "b", "c"]
as == bs
as = Set[1, 2, 3]
bs = Set[1, 2, 3]
as == bs
bs = Set[1r, 2, 3]
as == bs
Rational(1.6)
Rational(1.6) = 1.6r
Rational(1.6) == 1.6r
Rational("1.6") == 1.6r
require "bigdecimal"; BigDecimal.new(Rational(1.6), 18)
1 == 1r
1.eql? 1r
1.equal? 1r
1 === 1r
1.hash
1r.hash
[1] == [1r]
Set[1] == Set[1r]
Set[1].to_a == Set[1r].to_a
Set[1, 2].to_a == Set[1r, 2r].to_a
Set[1, 2].to_a == Set[2r, 1r].to_a
Set[1, 2].to_a.sort == Set[2r, 1r].to_a.sort
[1] - [1]
[1] - [1r]
[1].include? 1r
def set_eq s1, s2
Set[1, 2].include? 1r
[1, 2].include? 1r
Set[1, 2].to_a.include? 1r
def set_include_value? s, v
  s.to_a.include? v
end
def set_equal_values? s1, s1
def set_equal_values? s1, s2
def subset_on_values? s1, s2
def subset_on_values?(parent:, sub:)
  sub.all? { |v| parent.set_include_value? v }
end
Set[1, 2].set_include_value? 1r
def set_include_value?(set:, value:)
  set.to_a.include? value
end
set_include_value? set: Set[1, 2], value: 1r
def subset_on_values?(parent:, sub:)
  sub.all? { |v| set_include_value? set: parent, value: v }
end
subset_on_values? parent: Set[1, 2, 3], sub: Set[1]
subset_on_values? parent: Set[1, 2, 3], sub: Set[1r]
subset_on_values? parent: Set[1, 2, 3], sub: Set[1r, 2r]
subset_on_values? parent: Set[1, 2, 3], sub: Set[3r, 1r, 2r]
subset_on_values? parent: Set[1, 2, 3], sub: Set[3r, 1r, 2r, 4r]
def sets_equal_on_values? s1, s2
  subset_on_values?(parent: s1, sub: s2) && subset_on_values?(parent: s2, sub: s1)
end
sets_equal_on_values? Set[1, 2], Set[2r, 1r]
sets_equal_on_values? Set[1, 2], Set[[2r], 1r]
def splat *args
  Set.new args
end
splat [rat]
rat
splat ["rat"]
splat "rat"
splat "rat", "bat", "cat"
*["rat", "bat", "cat"]
["rat", "bat", "cat"]*
a = ["rat", "bat", "cat"]
a
a*
*a
b = *a
b
b, c = *a
b
c
b, *c = *a
b
c
*c
exit
self
scaled
exit
nil.is_a? Fixnum
require "dm_engine/entities/drugs/metformin_er.rb"
MetforminER.new
include DmEngine
MetforminER.new
self
dosings
[dosings].flatten
[dosings].flatten.map { |data| build_dosing_from data }
[dosings].flatten.map { |data| p data; build_dosing_from data }
exit
require "dm_engine/entities/drugs/metformin_er.rb"
include DmEngine
MetforminER.new
dosings
[dosings].flatten.map { |data| build_dosing_from data }
exit
Drug.new
self
dosings
dosings.is_a? DosingSchedule
DosingSchedule.new([dosings].flatten.map { |data| build_dosing_from data })
exit
Drug.new
exit
drugs
self.drugs
edit add
self.drugs
action
self.drugs[action]
exit
require "dm_engine/entities/drugs/drug"
include DmEngine
Drug.new
Drug.new.hash
nil.hash
require "dm_engine/entities/drugs/metformin_er"
MetforminER.new
a = b = "hi"
a
b
require "test/entities/test_dosing"
require "entities/test_dosing"
require "../test/entities/test_dosing"
pwd
.pwd
.ls
$PATH
$LOAD_PATH
require "~/Projects/dm_app/dm_engine/test/entities/test_dosing"
require "~/Projects/dm_app/dm_engine/test/test_helper""
require "~/Projects/dm_app/dm_engine/test/test_helper"
require "home/cort/Projects/dm_app/dm_engine/test/test_helper"
.pwd
require "#{.pwd}/test/test_helper"
load "home/cort/Projects/dm_app/dm_engine/test/test_helper.rb"
.ls
.ls test
load "/home/cort/Projects/dm_app/dm_engine/test/test_helper.rb"
load "/~/Projects/dm_app/dm_engine/test/test_helper.rb"
load "/home/cort/Projects/dm_app/dm_engine/test/test_helper.rb"
require "/home/cort/Projects/dm_app/dm_engine/test/entities/test_dosing"
$LOAD_PATH.unshift"test"
$LOAD_PATH.shift
$LOAD_PATH
$LOAD_PATH.unshift "/home/cort/Projects/dm_app/dm_engine/test"
require "entities/test_dosing"
DoseDouble.new
dd = DoseDouble.new
dd.amount
dd.unit
@dose_double = @object = DoseDouble.new
@dose_double
@object
show-doc Minitest::Mock
show-doc Minitest::Mock#initialize
show-doc Minitest::Mock#expect
a, b, c = *["a", ["b", "c"]]
a
b
c
a, b, c = *["a", *["b", "c"]]
a
b
c
*["a", *["b", "c"]]
["a", *["b", "c"]]
["a", *"b"]
a, b = ["a", *"b"]
a
b
m = Minitest::Mock.new
m.expect :add_atom, nil
m
ls m
m.send :add_atom
m.add_atom
m.expect :add_atom, nil
m.add_atom
help
reload-method Dosing#apply_dose_operation
m.expect :add_atom, nil
m.send(*[:add_atom].compact)
m
ls m
cd m
m.methods
a = *[nil].compact
a
*a = *[nil].compact
a
a, b = *[nil].compact
a
b
a, b = *[:add_atom, nil].compact
a
b
require "dm_engine/entities/drugs/drug"
drug = Drug.new
drug.restrict_to_max_daily_dose
def drug.restrict_to_max_daily_dose
  "restricted"
end
drug.restrict_to_max_daily_dose
exit
action
drugs
self.drugs
self.drugs[:choose]
self.drugs[:choose] + drugs
self.drugs[:choose] + [drugs]
exit
drug_lists
[Array(drug_lists)]
[Array(drug_lists)].any? { |drugs|
  drugs.any? { |drug| drug.name == name_string }
}
drug_lists.first
drug_lists.first.name
down
up
down
drug_lists
down
self
self.drugs[:start].first
self.drugs[:start].first.name
self.drugs[:start][1].name
self.drugs[:stop].first.name
exit
drug_lists
drug_lists.first.name
[Array(drug_lists)].any? { |drugs|
  drugs.any? { |drug| drug.name == name_string }
}
exit
drug_lists
drug_lists.first.name
[Array(drug_lists)].any? { |drugs|
  drugs.any? { |drug| drug.name == name_string }
}
exit
drug_lists
[Array(drug_lists)].any? { |drugs|
  drugs.any? { |drug| drug.name == name_string }
}
exit
drug_lists
[Array(drug_lists)].any? { |drugs|
  drugs.any? { |drug| drug.name == name_string }
}
exit
drug_lists
[Array(drug_lists)].any? { |drugs|
  drugs.any? { |drug| drug.name == name_string }
}
[Array(drug_lists)]
[].is_a? Enumerable
Array.ancestors
Array(1, 2)
[nil]
first, *rest = *1
first
rest
first, *rest = *[1]
first
rest
[] << "a"
exit
self
instructions
instructions && self.instructions + instructions
self.drugs[action] + drugs
exit
TestList
class TestList
  attr_reader :items
  def initialize items
    @items = Array(items).to_set
  end
  include Enumerable
  def each
    items.each { |item| yield item }
    self
  end
end
rats = TestList.new ["rat1", "rat2", "rat3"]
rats.each do |rat| puts rat end
rats.map { |rat| "super #{rat}" }
["a", "b"].map
["a", "b"].each
["a"] + ["b"]
[["a"]] + ["b"]
[["a"]] + [["b"]]
[1, 2] & [2, 1]
[1, 2] & [2, 1] == [2, 1] & [1, 2]
[2, 1] & [1, 2]
[2, 1] | [1, 2]
[2, 1].union  [1, 2]
[2, 1] + [1, 2]
ls []
? []#*
? Array#*
$ Array#*
ls Kernel
? Kernel#`
putc "muppet"; putc " haha"
putc "muppet"
puts "muppet"
? Kernel#putc
ls Array
ls Array.new
? Array#pack
ls Array
? Array#rassoc
? Array#assoc
Array([["a]])
Array([["a"]])
Array(["a"])
[Array(["a"])]
[Array([["a"]])]
[[1]] + [[2]]
Array([[1], [2]])
[*[1]]
first, *rest = *[1, 2, 3]
first
rest
first.is_a? Array
[Array(1}]
[Array(1)]
Array([[1]])
Array([1])
[Array([1])]
unless true
"rat" unless true
"rat" unless false
pt_data = Hash.new([])
pt_data[:drugs]
pt_data[:jackson] = "jackson"
pt_data[:jackson]
pt_data[:roo] << "roo"
pt_data[:roo]
RUBY_VERSION
[1] + nil
[nil].compact
a = ["a", "b", "c"]
a.select { |e| e == "a" }
a.where { |e| e == "a" }
ls a
? Array#collect
? Enumerable#collect
a = []
(!a.empty?) && a
jack = Class.new
jack
jack.new
jack.new.class
FailedObjectConversion = Class.new(StandardError)
FailedObjectConversion = Class.new
Jack = Class.new
Jack.new
jack = Jack.new
def jack.foo
  "foo"
end
jack.foo
Mup = Class.new
Mup.new
exit
drugs
drugs.select { |drug| drug.drug_class == "metformin" }
drugs.select { |drug| drug.drug_class == "metformin" }.first
metformin
adjuster
adjuster.try_adjust drugs: drugs.select { |drug| drug.drug_class == "metformin" }, treatment: treatment
exit
pt_data
drug_initializer
drug_initializer.metformin
drug_initializer.metformin(nil)
drug_starter.start(potential_drugs: drug_initializer.metformin(nil), current_drugs: nil)
drug_starter.start
drug_starter.start potential_drugs: "metformin", current_drugs: nil
drug_starter
$ drug_starter.start
exit
start_insulin
exit
start_insulin
start_insulin.run
exit
start_insulin.run
start_insulin.run pt_data
start_insulin.verify
exit
object
object.treatment
treatment
object.is_a?(TreatmentBuilderData)
treatment == object.treatment &&
treatment == object.treatment
pt_data == object.pt_data
drugs == object.drugs
object.drugs
drugs
exit
drugs
!!!
drugs
drugs.nil?
!drugs.is_a? Array
exit
drugs
!drugs.is_a?(Array)
exit
drugs
head, *tail = [[[TestStartInsulin::DrugDouble, TestStartInsulin::DrugDouble]]]
head
tail
head, *tail = *[["cat"]]
head
tail
head, *tail = *["cat"]
head
tail
head, *tail = *"cat"
head
tail
head, *tail = *[]
head
tail
!!!
drugs
drugs.empty?
!head.is_a? Array
exit
drugs
drugs.empty?
!head.is_a? Array
exit
drugs.empty?
exit
drugs.empty?
!head.is_a? Array
drugs
exit
drugs
exit
drugs
drugs.empty?
!head.is_a? Array
exit
drugs
exit
drugs
exit
drugs
head
tail
exit
drugs
head
tail
exit
drugs
head
tail
exit
drugs
head
tail
exit
drugs
head
tail
exit
drugs
head
tail
exit
drugs
head
tail
exit
drugs
head
tail
exit
drugs
drugs.first.first
drugs.first.first.dosing
drugs.first.first.new dosings: drugs.first.first.initial_dosings_for(regimen: "regimen", from_regimen: "from regimen", pt_data: "pt data")
drugs.first.last.new dosings: drugs.first.last.initial_dosings_for(regimen: "regimen", from_regimen: "from regimen", pt_data: "pt data")
drugs.last.last.new dosings: drugs.last.last.initial_dosings_for(regimen: "regimen", from_regimen: "from regimen", pt_data: "pt data")
drugs.last.first.last.new dosings: drugs.last.first.last.initial_dosings_for(regimen: "regimen", from_regimen: "from regimen", pt_data: "pt data")
drugs.last.first.first.new dosings: drugs.last.first.first.initial_dosings_for(regimen: "regimen", from_regimen: "from regimen", pt_data: "pt data")
!!!
drugs
new_drugs
new_drugs + [Array(drugs)]
new_drugs + Array(drugs)
[Array(drugs)]
self.class.new treatment: nil, pt_data: nil, new_drugs: "drugs"
exit
drug_starter
drug_starter.instance_variable_get @start_fn
drug_starter.instance_variable_get :@start_fn
$ drug_starter.new
start_fn
drug_starter.new(start_fn)
drug_starter.instance_variable_get :@start_fn
exit
drug_starter
exit
self
object
object.treatment_plan
object.patient
object.new_drugs
exit
step_data
treatment_plan
patient
exit
step_data
acc_step_data
step
up
down
out
back
exit
steps
steps.first
$ steps.first.run
exit
steps
steps.first
acc_step_data
exit
!!!
patient
exit
Mup = Class.new
j = Mup
j
def j.rat
  "rat"
end
ls Mup
j.rat
Mup.rat
h = Hash.new([])
h[:drugs].select { |drug| drug.drug_class == "foo" }
Hash[["a", ["b", "c"]]]
Hash["a", ["b", "c"]]
Hash[{ a: 1, b: 2 }.map { |k, v| [k, v] }]
{ a: 1, b: 2 }.map { |k, v| [k, v] }
{ a: [1, 1], b: [3, 4] }.map { |k, v| [k, v] }
{ a: [1, 2], b: [3, 4] }.map { |k, v| [k, v] }
Hash[{ a: [1, 2], b: [3, 4] }.map { |k, v| [k, v] }]
Hash[[[:a, [1, 2]], [:b, [3, 4]]]]
Hash[[["a", ["b", "c"]]]]
m = Minitest::Mock.new
require "minitest/autorun"
require "minitest/mock"
m = Minitest::Mock.new
m.expect :test, nil, [{ a: 1, b: 2 }]
ls m
m.test a: 1, b: 2
m.verify
"Metformin ER".constantize
"Metformin ER".gsub(\s, "")
"Metformin ER".gsub("\s", "")
"Metformin ER".gsub("\s", "").const_get
const_get("Metformin ER".gsub("\s", ""))
ls
ls Kernel
DmEngine::Drugs.const_get("Metformin ER".gsub("\s", ""))
require "dm_engine/entities/drugs/drug"
include DmEngine
DmEngine::Drugs.const_get("Metformin ER".gsub("\s", ""))
DmEngine::Drugs::MetforminER
require "dm_engine/entities/drugs"
DmEngine::Drugs::MetforminER
DmEngine::Drugs.const_get("Metformin ER".gsub("\s", ""))
DmEngine::Drugs.const_get("Metformin ER".gsub("\s", "")).new
[1, 2, 3] + 4
[1, 2, 3] + [4]
Set[1, 2, 3] + [4]
[1, 2, 3] + Set[4]
[].any?
? Set#classify
$ Set#classify
[[]].empty?
Set[].classify(&:drug_class)
Set[].classify(&:drug_class).map { |drug_class, list| Array(list) }
? Array#reduce
longest = %w{ cat sheep bear }.inject do |memo, word|
  memo.length > word.length ? memo : word
end
longest
[[[1], [2]], [[3], [4]]]
[[[1], [2]], [[3], [4]]].flatten
? Array#compact
# Array#compact
$ Array#compact
$ Array#compact!
require "lib/dm_engine/interactors/treatment_machinery/glucose/insulin_drug_adjuster"
.ls lib/dm_engine/interactors/treatment_machinery/glucose/
Hash["a", "b"]
$ Set#classify
["a", "b", "c"].to_set.classify { |e| e }.values
["a", "b", "c"].to_set.classify { |e| e }.values.map { |e| Array(e) }
module List
  ["a", "b", "c", "d"]
end
List
ls List
class List
  ["a", "b", "c", "d"]
end
List
List.class
undef
List
const_delete List
class L
  ["a", "b"]
end
L
ls L
[].send "<<", "a"
[] << "a"
[].send "<<", "a"
[] << "a"
[].send "<<", "a"
first, *rest = *1
first
rest
first, *rest = *[]
first
rest
first, *rest = *["cat"]
first
rest
a = [1, 2, 3]
a.shift
a
a.unshift
a.unshift(1)
a
a.unshift nil
a
a.shift
a
a.unshift []
a
"cat"[-1]
? Array#reduce
"foo"[0] == "f"
"foo"[-1] == "o"
"fee"[0] == "f"
"fee"[-1] == "o"
"boo"[0] == "f"
"boo"[-1] == "o"
[[], "a", [], "b", nil].compact
[[], "a", [], "b", nil].compact.delete([])
[[], "a", [], "b", nil].compact.delete("b")
["a", "b", "c"].include? ["a", "b"]
Set["a", "b", "c"].subset? ["a", "b"]
Set["a", "b", "c"].subset? Set["a", "b"]
Set["a", "b"].subset? Set["a", "b", "c"]
Set["a", "b"].subset? Set["a", "b"]
def test_hash_for_keywords(kw1:, kw2: nil, h = {})
def test_hash_for_keywords(kw1:, kw2: nil)
def test_hash_for_keywords(h= {}, kw1:, kw2: nil)
  p h
  p kw1
  p kw2
end
def keyword_args(kw1:, kw2:)
  p kw1,
def keyword_args(kw1:, kw2:)
  p kw1
  p kw2
end
def test_hash_for_keywords(h= {}, kw1:, kw2: nil)
def test_hash_for_keywords(h= {})
  keyword_args h
end
test_hash_for_keywords kw1: "kw1", kw2: "kw2"
def test_hash_for_keywords(h= {})
  send(:keyword_args, h)
end
test_hash_for_keywords kw1: "kw1", kw2: "kw2"
h = { a: "2" }
h[:b] = "3"
*[1, 2]
*1
a, *b = [1, 2]
a, *b = 1
a
b
a, *b = *1
a
b
a, *b = 1
a
b
a, *b = [1, 2]
a, *b = *[1, 2]
keyword_args kw1: "cat", kw2: "bat", kw3: "rat"
keyword_args kw1: "cat", kw2: "bat"
c
c = c
c
drugs = [
  [
drugs = [
  [
    "once-daily insulins"
  ]
]
drugs << ["once-daily insulins", "prandial insulins"]
[] + [[["spook", "rick"], ["rat", cat"]]]
[] + [[["spook", "rick"], ["rat", "cat"]]]
[] + [[["spook", "rick"]]] + [[["rat", "cat"]]]
[] + [["spook", "rick"]] + [[["rat", "cat"]]]
[] + [["spook", "rick"]] + [[["rat"], ["cat"]]]
? Minitest::Mock#expect
[1, 2, 3].push "a"
[1, 2, 3].unshift "a"
[].unshift "a"
[1, 2, 3].unshift []
[].unshift "drug"
[].unshift("drug")
[].unshift("drug3").unshift("drug2")
[].unshift([].unshift("drug3").unshift("drug2"))
def test_block_param args, &blk
  blk.call args
end
test_block_param ["cat", "rat"] do
  |e|
  puts e
end
def test_lambda_param args, blk
  blk.call args
end
test_lambda_param ["cat", "rat"], lambda { |e| puts e }
test_lambda_param ["cat", "rat"], ->(e){ puts e }
class TestClass
  def self.fn
    lambda { puts instance_method }
  end
  def initialize
    self.class.fn.call
  end
  def instance_method
    "instance"
  end
  amend-line 10
end
TestClass.new
edit
TestClass.new
def TestClass.fn
  lambda { puts b }
end
class TestClass
  def b
    "b"
  end
end
TestClass.new
require "dm_engine/entities/treatment_builder_data"
? TreatmentBuilderData#initialize
$ TreatmentBuilderData#initialize
require "dm_engine/interactors/treatment_machinery/recursive_drug_starter"
require "dm_engine/interactors/treatment_machinery/drug_progressors/recursive_drug_starter"
recur_start = RecursiveDrugStarter.new lambda { |drug, treatment_builder_data| drug }
include DmEngine
include TreatmentMachinery
include DrugProgressors
recur_start = RecursiveDrugStarter.new lambda { |drug, treatment_builder_data| drug }
recur_start.run drugs: [["basal"], ["prandial"]], treatment_builder_data: nil
treatment_builder_data = TreatmentBuilderData.new treatment: "treatment", pt_data: "pt data", new_drugs: [["basal"], ["prandial"]]
treatment_builder_data = TreatmentBuilderData.new treatment: "treatment", pt_data: "pt data", new_drugs: nil
help
reload-code --help
reload-code TreatmentBuilderData
ls TreatmentBuilderData
$ TreatmentBuilderData#add_new_drugs_option
$ TreatmentBuilderData#add_new_drugs
treatment_builder_data.add_new_drugs_option [["basal"], ["prandial"]]
((((1 + 1) * 1) / 1) - 1)
[:+, :*, :/, :-].reduce(1) { |acc, op| acc = acc.send op }
[:+, :*, :/, :-].reduce(1) { |acc, op| acc = acc.send op, acc }
[:+, :*, :/, :-].reduce(1) { |acc, op| acc = acc.send op, 1 }
def name obj
  "my name is #{obj}"
end
def hello str
  "hello, #{str}"
end
def status str
  "#{str}, how are you?"
end
[:hello, :name, :status].reduce("muppet") { |acc, fn| acc = acc.send fn, acc }
[:name, :hello, :status].reduce("muppet") { |acc, fn| acc = acc.send fn, acc }
def name str
  "#{str}"
end
[:name, :hello, :status].reduce("muppet") { |acc, fn| acc = acc.send fn, acc }
[:name, :hello, :status].reduce("muppet") { |acc, fn| acc.send fn, acc }
[:name, :status, :hello].reduce("muppet") { |acc, fn| acc.send fn, acc }
[:hello, :name, :status].reduce("muppet") { |acc, fn| acc.send fn, acc }
["tbd", "tbd2"].flatten
[["tbdD1", "tbdD2"], ["tbd2D1", "tbd2D2"]].flatten
reload-code TreatmentBuilderData
TreatmentBuilderData.new
test1 = Object.new
test1.instance_variable_set :@id, 1
test2 = Object.new
test2.instance_variable_set :@id, 2
test1
test 2
test2
class Holder
  def initialize contents
    @contents = contents
  end
  attr_reader :contents
  def make_new
    self.class.new contents
  end
end
h = Holder.new test1
h.make_new
g = h.make_new
h
g
h.contents
g.contents
h.instance_variable_set :@contents, test2
h
g
h.instance_variable_set :@contents, test1
h
g
test1.instance_variable_set :@id, 3
h
g
h.contents.instance_variable_set :@id, 4
h
g
def what_is_block &blk
  p blk.class
end
what_is_block { |e| p e }
what_is_block {}
[] + [["cat", "rat"]]
[[]] + [["cat", "rat"]]
[1, 2, 3, 4, 5].take(1)
[1, 2, 3, 4, 5].take(2)
[1, 2, 3, 4, 5].lazy.take(2)
a = [1, 2, 3, 4, 5].lazy.take(2)
a.to_a
a
[].first
exit
User.all
BigDecimal.new("1.5")
1.5r
BigDecimal.new("1.5") == 1.5r
DateTime.new.is_a? Date
Time.zone.now.is_a? Date
Time.zone.now.class
Time.zone.now.class.ancestors
Date.new "1/1/2000"
cd Date
cd ..
? Date#initialize
[3~$? Date#initialize
$ Date#initialize
exit
Patient.new study_assigned_id: 1, birthdate: "1/1/2000"
$ Patient.initialize
$ Patient.new
? Patient.new
A1c
Patient
p = Patient.new study_assigned_id: 1, birthday: Date.new(2000, 1, 13), smoker: false, etoh: false
p = Patient.new study_assigned_id: 1, birthdate: Date.new(2000, 1, 13), smoker: false, etoh: false
p.a1cs.build date: Date.today, a1c: 4
p.a1cs
p.reload
p
p.save
p.valid?
p.errors
p.a1cs.first.valid?
p.a1cs.first.errors
p.a1cs
p.a1cs.empty!
ls Array
p.a1cs.clear
p.a1cs
p
p.valid?
p.save
p.a1cs.build date: Date.today, a1c: 4
p.a1cs.clear
p.a1cs.create date: Date.today, a1c: 4
p.a1cs
A1c
A1c.new patient_id: 15, date: Date.new(2014, 3, 8), a1c: 4
a = A1c.new patient_id: 15, date: Date.new(2014, 3, 8), a1c: 4
a.valid?
ls A1c
? A1c.new
p
p.id
pt = Patient.create study_assigned_id: 1, birthdate: Date.new(2000, 1, 13)
pt = Patient.create study_assigned_id: 21, birthdate: Date.new(2000, 1, 13)
valid_date = Date.new 2010, 1, 13
valid_a1c = 1.5r
valid_a1c = A1c.new patient_id: pt.id, date: valid_date, a1c: @valid_a1c
valid_a1c.valid?
valid_a1c.errors
valid_a1c = A1c.new patient_id: pt.id, date: valid_date, a1c: valid_a1c
valid_a1c_value = 1.5r
valid_a1c = A1c.new patient_id: pt.id, date: valid_date, a1c: valid_a1c_value
valid_a1c = A1c.new patient_id: pt.id, date: valid_date, a1c: 1.5
valid_a1c = A1c.new patient_id: pt.id, date: valid_date, a1c: 1.5r
1.5r
valid_a1c = A1c.new patient_id: pt.id, date: valid_date, a1c: 1.5r.to_f
valid_a1c = A1c.new patient_id: pt.id, date: valid_date, a1c: 1.5r
valid_a1c = A1c.new patient_id: pt.id, date: valid_date, a1c: 1.5
valid_a1c = A1c.new patient_id: pt.id, date: valid_date, a1c: "1.5"
Date.new 1
p1 = Patient.new birthdate: 1, study_assigned_id: 2
p1.valid?
p1.errors
a1c = A1c.new patient_id: 1, date: 1, a1c: 1
a1c.valid?
a1c.errors
a1c = A1c.new patient_id: p.id, date: 1, a1c: 1
a1c.valid?
a1c.errors
p.a1cs.build date: 1, a1c: 1
a2 = p.a1cs.build date: 1, a1c: 1
a2.saved?
a2.save?
a2.valid?
a2.errors
a2.save
a2 = p.a1cs.build date: "1/13/2000", a1c: 1
a2.valid?
a2.errors
RAILS_ENV
ENV
Rails.environment
ls Rails
Rails.@_env
Rails._env
Rails.new
@_env
env
Rails.env
Rails.env = "test"
Rails.env
p = Patient.new study_assigned_id: 1, birthdate: Date.new(2000, 1, 13), smoker: false, etoh: false
a2 = p.a1cs.build date: 1, a1c: 1
a2.valid?
reload
help
reload A1c
reload-code A1c
A1c
path
.path
.$PATH
load "a1c"
load "a1c.rb"
Rails.env = "development"
p = Patients.first
p = Patient.first
p.a1cs
a2 = p.a1cs.build date: 1, a1c: 1
p.valid?
load "a1c.rb"
Patient.where(study_assigned_id: 15)
Patient.all
User
exit
patient
patient.methods
ls patient
whereami
patient.glucose_records?
!patient.glucose_records?
patient.on_dm_treatment?
!!!
exit
edit
edit-method get_treatments_for
edit get_treatments_for
help
.pry --version
exit
@start_monotherapy
ls
$ start_monotherapy_for
exit
start_metformin_for(patient)
start_non_metformin_non_insulin_glucose_drug_for(patient)
start_metformin_for(patient).product(start_non_metformin_non_insulin_glucose_drug_for(patient))
[1, 2].product([3, 4])
[1].product([3])
exit
comorbidities
help
help next
help step
whereami
step
@liver_disease
step
up
continue
$ Enumerable#collect
$ Enumerable#map
require "dm_engine/interactors/treatment/treatments/glucose/treatment"
.$PATH
require "bundle/setup"
exit
require "bundle/setup"
Bundler.require
$LOAD_PATH
require "dm_engine/interactors/treatment/treatments/glucose/treatment"
ls
include DmEngine
ls Treatment::Treatments::Glucose::Treatment
ls Treatment::Treatments::Glucose::Treatment#start_metformin_for
Treatment::Treatments::Glucose::Treatment#start_metformin_for
$ Treatment::Treatments::Glucose::Treatment#start_metformin_for
$ Treatment::Treatments::Glucose::Treatment.start_metformin_for
? Treatment::Treatments::Glucose::Treatment.start_metformin_for
exit
Bundler.setup
$LOAD_PATH
exit
$LOAD_PATH
require "bundler"
require "bundler/setup"
exit
require "bundler/setup"
require "bundler"
load "dm_engine/interactors/treatment/treatments/start_glucose_treatment.rb"
include DmEngine
ls Treatment::Treatments::StartGlucoseTreatment
load "dm_engine/interactors/treatment/treatments/start_glucose_treatment.rb"
ls Treatment::Treatments::StartGlucoseTreatment
exit
step
head
step
head
*tail
tail
step
self
drug_option_group
self.class.new drug_options.product drug_option_group.drug_options
!!!
optionses
optionses.map { |e| p e }
!!!
optionses
optionses.map { |e| p e }
optionses.map { |drug_optionses| TreatmentPlanDrugs.new drug_optionses }
exit
require "dm_engine/data_access/in_memory_drug_repository"
require "test/interactors/treatment/treatments/test_glucose_treatment_components"
.pwd
$LOAD_PATH
`pwd
`
`pwd`.chomp
File.join(`pwd`.chomp, "../test")
File.join(`pwd`.chomp, "test")
$LOAD_PATH.unshift File.join(`pwd`.chomp, "test")
require "test/interactors/treatment/treatments/test_glucose_treatment_components"
require "interactors/treatment/treatments/test_glucose_treatment_components"
include DmEngine
base = Treatment::Treatments
dr = DataAccess::InMemoryDrugRepository.new [base::Metformin1Double, base::Metformin2Double, base::BasalInsulin1Double, base::BasalInsulin2Double, base::Sulfonylurea1Double, base::Sulfonylurea2Double, base::GLP1Agonist1Double, base::GLP1Agonist2Double]
dr.get_metformins
dr.get_non_metformin_non_insulin_glucose_drugs
$ Array#group_by
? Array#group_by
dr.get_non_metformin_non_insulin_glucose_drugs.group_by { |e| e.drug_class }
dr.get_metformins
dr.get_metformins.product(
  dr.get_non_metformin_non_insulin_glucose_drugs
)
dr.get_non_metformin_non_insulin_glucose_drugs
require "dm_engine/interactors/treatment/treatments/glucose_treatment_components"
load "dm_engine/interactors/treatment/treatments/glucose_treatment_components.rb"
base
base::GlucoseTreatmentComponents.start_metformin_for "pt"
base::GlucoseTreatmentComponents.instance_variable_set :@dr, dr
base::GlucoseTreatmentComponents.start_metformin_for "pt"
require "dm_engine/entities/patient"
require "dm_engine/entities/comorbidites"
require "dm_engine/entities/comorbidities"
pt = Patient.new
pt = Patient.new comorbidities: Comorbidities.new
base::GlucoseTreatmentComponents.start_metformin_for pt
load "dm_engine/entities/drug_options.rb"
load "dm_engine/entities/treatment_plan_drugs.rb"
load "dm_engine/entities/drug_options_group.rb"
base::GlucoseTreatmentComponents.start_metformin_for pt
base::GlucoseTreatmentComponents.start_non_metformin_non_insulin_glucose_drugs_for pt
base::GlucoseTreatmentComponents.start_non_metformin_non_insulin_glucose_drug_for pt
met = base::GlucoseTreatmentComponents.start_metformin_for pt
n = base::GlucoseTreatmentComponents.start_non_metformin_non_insulin_glucose_drug_for pt
met.product n
["a"].product
def fibgen a, b
[1, 2, 3, 4, 5, 6].lazy
a = [1, 2, 3, 4, 5, 6].lazy
a.first
a.take 1
a.take(1).force
a.drop(1)
a.first
a.drop(1).force
a
a.first
a.next
a.first
a.next
a.reset
ls a
a.peek
a.rewind
a.next
a.rewind
? Enumerator#rewind
? Enumerable#each_cons
a.force
a
a.force
a.to_a
a
Array(a)
a
["dog", "cat"]["dog"]
help
include "minitest"
require "minitest"
ls Minitest
ls Minitest::Assertions
? Minitest::Assertions#assert_includes
["a"].product["b"]
["a"].product(["b"])
require "dm_engine/entities/drug_options"
d1 = DrugOptions.new ["11", "12"]
d2 = DrugOptions.new ["21", "22"]
d1.product d2
help
reload-code DrugOptions#product
d1.product d2
d1.empty?
reload-code DrugOptions#product
d1.empty?
ls DrugOptions
d1 = DrugOptions.new ["11", "12"]
d1.empty?
d2 = DrugOptions.new ["21", "22"]
d1.product d2
["a", "b"].product []
["a", "b"].product nil
["a", "b"].product()
["a", "b"].product(nil)
load "dm_engine/entities/drug_options"
load "dm_engine/entities/drug_options.rb"
load "dm_engine/entities/drug_options_group.rb"
a1 = ["a11", "a12", "a13"]
a2 = ["a21", "a22", "a23"]
d1 = DrugOptionsGroup.new [a1]
include DmEngine
d1 = DrugOptionsGroup.new [a1]
d2 = DrugOptionsGroup.new [a2]
d1.product d2
load "dm_engine/entities/drug_options_group.rb"
a1 = ["a11", "a12", "a13"]
a2 = ["a21", "a22", "a23"]
d1 = DrugOptionsGroup.new [a1]
d2 = DrugOptionsGroup.new [a2]
d1.product d2
drug_options_groups
*drug_options_groups
*drug_options_groups.map { |drug_options_group| drug_options_group.drug_options
}
*drug_options_groups.map { |drug_options_group| drug_options_group.drug_options }
drug_options_groups.map { |drug_options_group| drug_options_group.drug_options }
drug_options
drug_options.product([[["a21", "a22", "a23"]]])
drug_options.product([["a21", "a22", "a23"]])
drug_options.first.product([["a21", "a22", "a23"]])
drug_options.first.product(["a21", "a22", "a23"])
*["a21", "a22", "a23"].map { |e| p e }
DrugOptions
do1 = DrugOptions.new ["o11", "o12"]
do2 = DrugOptions.new ["o21", "o22"]
do1.product do2
[do1, do2].product [do1, do2]
do3 = DrugOptions.new ["o31", "o32"]
do43 = DrugOptions.new ["o41", "o42"]
[do1, do2].product [do3, do4]
do4 = DrugOptions.new ["o41", "o42"]
[do1, do2].product [do3, do4]
[do1, do2].flat_map { 
  |do|
[do1, do2].flat_map { |do|
[do1, do2].flat_map { |d|
  d.product [do3, do4]
}
[do1, do2].flat_map { |d|
  [do3, do4].flat_map { |id|
    d.product id
  }
}
do1
DrugOptionsGroup.new [do1, do2]
dog12 = DrugOptionsGroup.new [do1, do2]
dog3 = DrugOptionsGroup.new [do3]
dog12.drug_options.flat_map { |drug_options|
  [dog3].map { |drug_options_group| drug_options_group.drug_options }
}
dog12.drug_options.flat_map { |drug_options|
  [dog3].map { |drug_options_group| drug_options_group.drug_options }
  .flatmap { |other_drug_options_group| drug_options.product other_drug_options_group }
  dog12.drug_options.flat_map { |drug_options|
    [dog3].map { |drug_options_group| drug_options_group.drug_options }
    .flatmap { |other_drug_options| drug_options.product other_drug_options }
  }
load "dm_engine/interactors/treatment/treatments/start_glucose_treatment.rb"
ls Treatment::Treatments::StartGlucoseTreatment
include DmEngine
ls Treatment::Treatments::StartGlucoseTreatment
load "dm_engine/interactors/treatment/treatments/start_glucose_treatment.rb"
ls Treatment::Treatments::StartGlucoseTreatment
ls Module
ls Object
ls Kernel
? Kernel#extend
? Module#include
$ Module#include
ls Treatment::Treatments::StartGlucoseTreatment
sgt = Treatment::Treatments::StartGlucoseTreatment
sgt.start_monotherapy_for
sgt.start_metformin_for
load "dm_engine/interactors/treatment/treatments/start_glucose_treatment.rb"
sgt = Treatment::Treatments::StartGlucoseTreatment
sgt.start_metformin_for
[].shift
nil.each do p "ran" end
[1, 2, 3].shift
n = []
n.shift
n
n = "one::two::three".split("::")
n
n.shift if n.empty? || n.first.empty?
n
DmEngine
DmEngine.const_get "Logic"
DmEngine.const_get "Treatment"
DmEngine.const_get :treatment
DmEngine.const_get :Treatment
:d::b
"d::b"
require "benchmark"
num = 1_000_000
Benchmark.bmbm(20) do |bm|
  bm.report("symbol") do
    Kernel.const_get "DmEngine"
  end
Benchmark.bmbm(20) do |bm|
  bm.report("symbol") do
    num.times do
      Kernel.const_get :DmEngine
    end
  end
  bm.report("string") do
    num.times do
      Kernel.const_get "DmEngine"
    end
  end
end
hist[39]
history[39]
help
help hist
hist --replay 39
hist[39] --replay
hist
help hist
hist --replay 1720..1721
hist --replay 1720...1721
hist --replay 1720..1722
hist --replay 1710..1721
num = 10_000_000
hist --replay 1710..1721
[0..2]
[0..8].each do |i| p i end
[0..8].class
(0..8).class
(0..8).each do |i| p i end
[0..2].first
(0..8)
(0..8).lazy
(0..8).take(1)
(0..8).lazy.take(1)
e = (0..8).lazy
e.take(1)
ls Enumerator::Lazy
? Enumerator::Lazy#take
$ Enumerator::Lazy#take
(0..8).lazy.first(3)
(0..8).lazy.class
def integers_from n
  1..Float::INFINITY
end
def integers_from n
  (1..Float::INFINITY).lazy
end
integers_from 1
integers_from(1).first(100)
integers_from(1).first(8)
def fibgen
type
instructions
!!!
type
instructions
start_drug_option_lists
!!!
start_drug_option_lists
start_drug_option_lists.first
DrugOptionList
test = DrugOptionList.new "type", ["drugs"]
Array(test)
test
[test]
!!!
start_drug_option_lists
exit
["a", "b", "c"].each &:p
[["a"], ["b"], ["c"]].map &:first
["a", "b", "c"]
[["a1",  "b", "c"]
[["a1", "a2"],  ["b1", "b2"], ["c1", "c2"]]
[["a1", "a2"],  ["b1", "b2"], ["c1", "c2"]].flatten
[[["a", "a1"], ["a", "a2"]],  [["b", "b1"], ["b", "b2"]], [["c", "c1"], ["c", "c2"]]]
[[["a", "a1"], ["a", "a2"]],  [["b", "b1"], ["b", "b2"]], [["c", "c1"], ["c", "c2"]]].flatten
[[["a", "a1"], ["a", "a2"]],  [["b", "b1"], ["b", "b2"]], [["c", "c1"], ["c", "c2"]]].flatten(1)
? Array#flatten
? Array#flat_map
[[["a", "a1"], ["a", "a2"]],  [["b", "b1"], ["b", "b2"]], [["c", "c1"], ["c", "c2"]]].flatten(2)
[[["a", "a1"], ["a", "a2"]],  [["b", "b1"], ["b", "b2"]], [["c", "c1"], ["c", "c2"]]].flatten(3)
[[["a", "a1"], ["a", "a2"]],  [["b", "b1"], ["b", "b2"]], [["c", "c1"], ["c", "c2"]]].flatten(4)
[[["a", "a1"], ["a", "a2"]],  [["b", "b1"], ["b", "b2"]], [["c", "c1"], ["c", "c2"]]].flatten(1)
[[["a", "a1"], ["a", "a2"]],  [["b", "b1"], ["b", "b2"]], [["c", "c1"], ["c", "c2"]]].flatten(0)
[[["a", "a1"], ["a", "a2"]],  [["b", "b1"], ["b", "b2"]], [["c", "c1"], ["c", "c2"]]].flatten(-1)
["a", "b", "c"].map { |e| [[e, e+1], [e, e+2]] }
["a", "b", "c"].map { |e| [[e, e + "1"], [e, e + "2"]] }
["a", "b", "c"].flat_map { |e| [[e, e + "1"], [e, e + "2"]] }
[].enumerable?
[].is_a? Enumerable
[].kind_of? Enumerable
[].instance_of? Enumerable
a = [1, 2, 3]
a.pop
a
a[0,-1]
a[0]
a[-1]
a[0..-1]
a[0..-2]
[1, 2, 3].flat_map { |e| e + 1 }
const_get :array
ls Object
ls Kernel
ls BasicObject
help
find-method const_get
ls Module
? Module#const_get
const_get(:Array)
Module.const_get(:Array)
Object.ancestora
Object.ancestors
Module.ancestors
$LOAD_PATH
load "dm_engine/interactors/treatment_options_determiner.rb"
include DmEngine
filter1 = Object.new
def filter1.run str
  ["filter1 #{str} 1", "filter1 #{str} 2"]
end
filter1.run "dog"
filter2 = Object.new
def filter2.run str
  ["filter2 #{str} 1", "filter2 #{str} 2"]
  emd
  amend-line
end
filter2.run "dog"
Util.pipeline [filter1, filter2], "dog"
Util.pipeline [filter1, filter2], ["dog"]
edit Util.pipeline
Util.pipeline [filter1, filter2], ["dog"]
reload-method Util.pipeline
Util.pipeline [filter1, filter2], ["dog"]
Util.pipeline [filter2, filter1], ["dog"]
Util.pipeline [filter1, filter1], ["dog"]
Util.pipeline [filter1, filter1], ["dog", "cat"]
Util.pipeline [filter1, filter2, filter1], ["dog", "cat"]
class MyStruct < Struct
  # Override the initialize to handle hashes of named parameters
  def initialize *args
    return super unless (args.length == 1 and args.first.instance_of? Hash)
    args.first.each_pair do |k, v|
      self[k] = v if members.map {|x| x.intern}.include? k
    end
  end
end
TestKWStruct = MyStruct.new :animal, :name
rick = TestKWStruct.new animal: "dog", name: "rick"
other_rick = TestKWStruct.new "dog", "rick"
rick_with_extra = TestKWStruct.new animal: "dog", name: "rick", color: "grayish"
def MyStruct.initialize *args
  return super unless (args.length == 1 and args.first.instance_of? Hash)
  args.first.each do |k, v|
    self[k] = v
  end
end
rick1 = TestKWStruct.new animal: "dog", name: "rick"
rick_with_extra1 = TestKWStruct.new animal: "dog", name: "rick", color: "grayish"
TestKWStruct = Mystruct.new
TestKWStruct = MyStruct.new
TestKWStruct = MyStruct.new :animal, :name
rick1 = TestKWStruct.new animal: "dog", name: "rick"
rick_with_extra1 = TestKWStruct.new animal: "dog", name: "rick", color: "grayish"
$ TestKWStruct#initialize
KWStruct = MyStruct.new :animal, :name
$ KWStruct#initialize
class KWStruct < Struct
  def initialize *args
    super *args unless args.length == 1 && args.first.is_a? Hash
class KWStruct < Struct
  def initialize *args
    super *args unless (args.length == 1 && args.first.is_a? Hash)
    args.first.each do |k, v|
      self[k] = v
    end
  end
end
class KWStruct < Struct
  def initialize *args
    super *args unless (args.length == 1 && args.first.is_a?(Hash))
    args.first.each do |k, v|
      self[k] = v
    end
  end
end
class MyKWStruct < Struct
  def initialize *args
    super *args unless (args.length == 1 && args.first.is_a?(Hash))
    args.first.each do |k, v|
      self[k] = v
    end
  end
end
Animal = MyKWStruct.new :type, :name
rick = Animal.new type: "dog", name: "rick"
extra = Animal.new type: "dog", name: "rick", color: "grayish"
AnimalStruct = Struct.new :type, :name
rick = AnimalStruct.new "dog", "rick"
extra = AnimalStruct.new "dog", "rick", "grayish"
require "keyword_struct"
MyAnimal = KeywordStruct.new :type, :name
rick = MyAnimal.new type: "dog", name: "rick"
rick1 = MyAnimal.new type: "dog", name: "rick", color: "grayish"
rick1 = MyAnimal.new type: "dog", name: "rick", "grayish"
require "dm_engine/entities/datum"
TreatmentDatum.new pt: "pt", plan: "plan", treatment_type: "type", treatment: "treatment"
td = TreatmentDatum.new pt: "pt", plan: "plan", treatment_type: "type", treatment: "treatment"
td.pt
p td
load "dm_engine/entities/treatment_datum.rb"
td = TreatmentDatum.new "pt", "plan", "type", "treatment"
load "keyword_struct.rb"
td = TreatmentDatum.new "pt", "plan", "type", "treatment"
args
args.length == 1 && args.first.instance_of?(Hash)
super *args
*args
super(*args)
self
self.class
self.ancestors
self.class.ancestors
self.class
self.class.super
super
args
super
super "dog"
self.class
self.class.super
self.class.ancestors.first.initialize *args
self.class.ancestors.first.send :initialize, *args
self.class.ancestors.first.send :new, *args
exit
self.class.ancestors[1].send :new, *args
self.class.ancestors[1]
self.class.ancestors[0]
self.class.ancestors[1]
self.class.ancestors[2]
self.class.ancestors[2].send :new, *args
self.class.ancestors[0].send :new, *args
step
!!!
self
exit
load "keyword_struct.rb"
load "dm_engine/entities/treatment_datum.rb"
td = TreatmentDatum.new "pt"
step
help
next
finish
continue
nil.some_method_nil_doesnt_know_about
nil.to_s
nil.inspect
$ Object#nil?
false.nil?
true.nil?
nil.nil?
Object.is_a? Object
Object.new.object_id
Object.new.object_id.class
0.object_id
1.object_id
2.object_id
-1.object_id
-2.object_id
100.object_id
[1, 2, 3, 4][0, 1]
[1, 2, 3, 4][0, 2]
[1, 2, 3, 4][0, 3]
[1, 2, 3, 4][1, 1]
[1, 2, 3, 4][0, 0]
[1, 2, 3, 4][2, 2]
[1, 2, 3, 4][1, 2]
[1, 2, 3, 4][1, 3]
[1, 2, 3, 4][3, -1]
[1, 2, 3, 4][3, 1]
[1, 2, 3, 4][2, 1]
[1, 2, 3, 4][2, 2]
[1, 2, 3, 4][5, 5]
[1, 2, 3, 4][5, 0]
array = [:peanut, :butter, :and, :jelly]
array[4,0]
array[4]
a = [1, 2, 3, 4][5]
a = [1, 2, 3, 4][5, 0]
a = [1, 2, 3, 4][4, 0]
a = [1, 2, 3, 4][4]
a = [1, 2, 3, 4][4, 100]
Hash[[:one, "eins"], [:two, "dos"]]
Hash[:one, "eins", :two, "dos"]
hash = { "jim" => 53, "amy" => 20, "dan" => 23 }
new_hash = hash.merge({ "jim" => 54, "jenny" => 26 })
%q(mmkay, mmkay)
%q[mmkay, mmkay]
%q%mmkay, mmkay%
%(mmkay, mmkay)
'\\\''
exit
drug_class_1
drug_class_2
k
v
["b", "a"].sort
["a", "b"].sort
[drug_class_1, drug_class_2].sort
drug_class_1 < drug_class_2
drug_class_1 > drug_class_2
drug_class_1 == drug_class_2
"dog" < "dob"
"dog" < "dog"
"dof" < "dog"
"a preceding non-existent drug class" < "DPPi"
"a preceding non-existent drug class" < "dPPi"
exit
pt_plan_drugs
!!!
pt_plan_drugs
continue
pt_plan_drugs
whereami
edit filtered
continue
drugs
!!!
load "keyword_struct.rb"
load "dm_engine/entities/treatment_datum.rb"
td = TreatmentDatum.new "pt"
[1, 2].product([])
[1, 2].product()
f, *r = *[1, 2]
f
r
f, *r = *[[1, 2]]
f
r
f.product(*r)
["n1"].product(*[["n2"]])
fg
["a", "b", "c", "d"].include? "a", "e", "f"
max
Math.max
Fixnum.max
Comparable.max
help
["a", "b"].max
["a", "b"].min
["a", "b"].sort.first
key, value = ["b", "a"].sort
key
value
nil.include? "a"
"a" < "D"
"Rick is " + :small
"Rick is " + :small.to_s
"Rick the dog" =~ "dog"
"dog" =~ "Rick the dog"
"Rick the dog" ~= "dog"
? String#=~
? Object#=~
"Rick the dog" =~ /dog/
"Rick the dog" =~ /dot/
"Rick the dog".match "dog"
"Rick the dog".match("dog").class
"Rick the dog".match("dog").class.ancestors
ls MatchData
exit
first
!!!
first
rest
first.product(rest)
change_drugs_lists
drug_change_type
change_drugs_lists.map(&:last)
!!!
change_drugs_lists
!!!
change_drugs_lists
change_drugs_lists.map { |list| list[1..-1] }
first
rest
first.product(*rest)
!!!
rest
res
res.reduce(:+)
[res].reduce(:+)
continue
lists
exit
change_drugs_lists
*drug_opt_lists_from(change_drugs_lists)
drug_opt_lists_from(change_drugs_lists)
drug_opt_lists_from(*change_drugs_lists)
!!!
drug_opt_lists_from(*change_drugs_lists)
combinations_of(*drug_opt_lists_from(*change_drugs_lists))
combinations_of(drug_opt_lists_from(*change_drugs_lists))
!!!
continue
lists
continue
lists
lists.reduce :+
continue
drug_opt_lists_from(*change_drugs_lists)
drug_opt_lists_from(*change_drugs_list_lists)
!!!
drug_opt_lists_from(*change_drugs_list_lists)
!!!
drug_opt_lists_from(*change_drugs_list_lists)
!!!
drug_opt_lists_from(*change_drugs_list_lists)
!!!
drug_opt_lists_from(*change_drugs_list_lists)
!!!
res
!!!
r
drug_opt_lists_from(*change_drugs_lists)
!!!
continue
change_drugs_lists
continue
r
exit
r
!!!
r
change_drugs_lists
change_drugs_lists.map { |list| list.flat_map(&:last) }
change_drugs_lists.flat_map { |list| list.map(&:last) }
!!!
r
continue
r
continue
r
continue
lists.reduce :+
continue
drug_opt_lists
callee
help
up
change_drugs_lists
up
glucose_treatment_components.start_metformin_for(pt)
glucose_treatment_components
glucose_treatment_components.drug_repository
!!!
rb_drug_classes
!!!
rb_drug_classes
rb_drug_classes.select { |rdc| rdc.drug_class == "metformin" }
exit
rb_drug_classes.select { |rdc| rdc.drug_class == "metformin" }
continue
drug_opt_lists
step
first
rest
step
first
rest
first.product *rest
up
continue
acc
continue
acc
whereami
edit
whereami
edit run
continue
acc_datum
continue
add_datum
acc_datum
edit run
!!!
continue
acc_datum
continue
drug_opt_lists
pt
acc_drug_opt_lists
acc_drug_opt_list
step
drugs
step
drug
pt.ok_drugs.any? { |current_drug| drug.drug_class == current_drug.drug_class }
step
continue
drug_filter
step
acc_drug_opt_list
step
drugs
drugs.select { |drug| drug.daily_dose <= drug.max_daily_dose }
drugs
drugs.first
drugs.first.daily_dose
exit
acc_drug_opt_list
continue
component
acc_datum
continue
component
acc_datum
continue
component
acc_datum
continue
component
acc_datum
continue
component
acc_datum
continue
component
acc_datum
continue
component
continue
component
acc_datum
acc_data
continue
component
acc_data
exit
continue
component
acc_data
exit
acc_data
continue
[1, 2, 3].map &:[1..-1]
[1, 2, 3].map(&:[1..-1])
[1, 2, 3].map(&:[])
[1, 2, 3].map(&:[], 1..-1)
[1, 2, 3].map(&:[], (1..-1))
ls Array
? Array#combination
pwd
`pwd`
`pwd`.chomp
$: << `pwd`.chomp
`find . -name '*.rb'`
`find . -name '*.rb'`.split
`find . -name '*.rb'`.split.each { |f| load f }
exceptions = [
  "./lib/dm_engine/logic/glucose/adjust_basal_insulin.rb",
  "./lib/dm_engine/logic/glucose/adjust_insulin.rb"
  ,
exceptions = [
  "./lib/dm_engine/logic/glucose/adjust_basal_insulin.rb",
  "./lib/dm_engine/logic/glucose/adjust_insulin.rb",
  "./lib/dm_engine/logic/glucose/adjust_fast_acting_insulin.rb",
]
.cat "./lib/dm_engine/logic/glucose/start_treatment.rb"
`find . -name '*.rb'`.split.each { |f| load f unless exceptions.include?(f) }
`find . -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e }
`find . -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
exceptions << "./lib/dm_engine/use_cases/"
exceptions << "./test/use_cases/"
`find . -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
exceptions << "./lib/dm_engine/treatment/treatments/treatment.rb"
`find . -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
`find . -name '*.rb'`.split.map { |fn| fn[0..-4] }.each { |f| require f unless exceptions.any? { |e| f.match(e) } }
`find . -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
`pwd`.chomp
File.join(`pwd`.chomp, "test")
.ls test
$: << File.join(`pwd`.chomp, "test")
`find . -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
`find . -name '*.rb'`.split.map { |fn| fn[2..-1] }
`find . -name '*.rb'`.split
`find . -name '*.rb'`.split.map { |fn| fn[2..-1] }
`find . -name '*.rb'`.split.map { |fn| fn[3..-1] }
`find . -name '*.rb'`.split.map { |fn| fn.split("/").map { |fn| fn[2..-1] }.join("/") }
`find . -name '*.rb'`.split.map { |fn| fn.split("/") }
`find . -name '*.rb'`.split.map { |fn| fn.split("/").map { |fn| fn[2..-1] } }
`find . -name '*.rb'`.split.map { |fn| fn.split("/") }.map { |fn| fn[2..-1] }
`find . -name '*.rb'`.split.map { |fn| fn.split("/") }.map { |fn| fn[2..-1] }.join("/")
`find . -name '*.rb'`.split.map { |fn| fn.split("/") }.map { |fn| fn[2..-1] }.map { |fn| fn.join("/") }
exceptions
exceptions.map { |fn| fn.split("/") }.map { |fn| fn[2..-1] }.map { |fn| fn.join("/") }
exceptions << "test/treatment/treatments/treatment_test.rb"
exceptions.pop
exceptions << "./test/treatment/treatments/treatment_test.rb"
`find . -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
$:
`find . -name './**/*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
`find ./lib -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
exceptions
3.times do exceptions.pop end
exceptions
`find ./lib -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
exceptions << "./lib/dm_engine/treatment/treatments/treatment.rb"
`find ./lib -name '*.rb'`.split.each { |f| load f unless exceptions.any? { |e| f.match(e) } }
def exceptions
@require_exceptions = exceptions
def require_all
  begin
    `find ./lib -name '*.rb'`.split.each { |f| load f unless @require_exceptions.any? { |e| f.match(e) } }
  rescue LoadError => e
def require_all
  begin
    `find ./lib -name '*.rb'`.split.each { |f| load f unless @require_exceptions.any? { |e| f.match(e) } }
    "required files"
    begin
def require_all
  begin
    `find ./lib -name '*.rb'`.split.each { |f| load f unless @require_exceptions.any? { |e| f.match(e) } }
    "required files"
  rescue LoadError => e
    p e
  end
end
require_all
help
edit require_all
load "test_helper.rb"
load "treatment/test_treatment_implementer.rb"
include DmEngine
include Treatment
TestTreatmentImplementer.test_start_monotherapy_when_pt_can_start_met_and_other_nmni_glucose
TestTreatmentImplementer.new.test_start_monotherapy_when_pt_can_start_met_and_other_nmni_glucose
? Set:+
? Set#+
$ Set#+
require "set"
Set["a", "b", "c"] + ["d"]
Set[Set[]] + []
Set[Set[]] + [[]]
[Set[] + [[]]
Set[] + [[]]
a = ["test"]
Set[a]
reload_all
pda = Treatment::PlanMakers::ProgressedDrugsAdder.new
pda.as_sets [["1", "2", "3"], ["4", "5"], [["6", "7"], "8"]]
pda.as_sets []
pda.as_sets [[]]
pda.as_sets [[1]]
pda.as_sets [1]
const_get :Array
Object.const_get :Array
Object.const_get "Array"
"array".capitalize
"array_with_underscores".capitalize
"array_with_underscores".title_case
gem-cd ActiveSupport
.gem list
.pwd
exit
gem-cd activesupport
`gem list`
exit
def hello name
  "hello, #{name}"
end
def hello name
  "hello, #{name}"
end
hello "ricktastic roo"
def hello name
  "hello, #{name}"
end
exit
def hello name
  p "Hello, #{name}"
end
def hello name
  p "Hello, #{name}"
end
hello "Rick"
4 + 2
hello "Silly animal"
def hello name
  "Hello, #{name}"
end
hello "Silly animal"
reload hello
reload #hello
reload Object#hello
edit hello
reload-method hello
def hello name
  "Hello, #{name}."
end
hello "Silly animal"
hello "silly animal"
def hello name
  "Hello, #{name}."
end
4 + 2
hello "silly animal"
exit
include DmEngine
def self.initial_dosings_for comorbidities
  DosingSchedule.new(
    [
      Dosing.new(
        time: "am",
        dose: Dose.build(
          amount: dose_amounts_for(comorbidities).uniq,
          unit: "units"
        )
      )
    ]
  )
end
exit
include DmEngine
Drugs
exit
def self.initial_dosings_for comorbidities
  DosingSchedule.new(
    [
      Dosing.new(
        time: "am",
        dose: Dose.build(
          amount: dose_amounts_for(comorbidities).uniq,
          unit: "units"
        )
      )
    ]
  )
end
include DmEngine
Drugs::Glargine
test
"test"
load %
module DmEngine
  module Drugs
    class Glargine < Drug
      def self.initial_dosings_for comorbidities
        DosingSchedule.new(
          [
            Dosing.new(
              time: "am",
              dose: Dose.build(
                amount: dose_amounts_for(comorbidities).uniq,
                unit: "units"
              )
            )
          ]
        )
      end
      def name
        "Glargine"
      end
      # private
      def self.dose_amounts_for comorbidities
        min_mult, max_mult = dose_amount_multipliers_for comorbidities
        [
          dose_amount_for(pt_mass: comorbidities.mass_in_kilograms, multiplier: min_mult),
          dose_amount_for(pt_mass: comorbidities.mass_in_kilograms, multiplier: max_mult)
        ]
      end
      def self.dose_amount_multipliers_for comorbidities
        case
        when comorbidities.a1c <= 8
          [0.1r, 0.2r]
        when comorbidities.a1c > 8
          [0.2r, 0.25r]
        end
      end
      def self.dose_amount_for(pt_mass:, multiplier:)
        (pt_mass * multiplier).floor
      end
    end
  end
end
exit
load'/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drugs/glargine.rb';
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drugs/glargine.rb'
Glargine.new dosings: "dosings"
Drugs::Glargine.new dosings: "dosings"
include DmEngine
Glargine.new dosings: "dosings"
Drugs::Glargine.new dosings: "dosings"
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drugs/glargine.rb'
def self.initial_dosings_for comorbidities
  DosingSchedule.new(
    [
      Dosing.new(
        time: "am",
        dose: Dose.build(
          amount: dose_amounts_for(comorbidities).uniq,
          unit: "units"
        )
      )
    ]
  )
end
Drugs::Glargine.initial_dosings_for(Object.new do def mass_in_kilograms; 10; end; def a1c; 8; end end)
o = Object.new
def o.mass_in_kilograms = 10
def o.mass_in_kilograms; 10; end
def o.a1c; 8; end
Drugs::Glargine.initial_dosings_for(o)
exit
module DmEngine
  module Drugs
    class Glargine < Drug
      def self.initial_dosings_for comorbidities
        DosingSchedule.new(
          [
            Dosing.new(
              time: "am",
              dose: Dose.build(
                amount: dose_amounts_for(comorbidities).uniq,
                unit: "units"
              )
            )
          ]
        )
      end
      def self.initial_dosings_for comorbidities
        DosingSchedule.new(
          [
            Dosing.new(
              time: "am",
              dose: Dose.build(
                amount: dose_amounts_for(comorbidities).uniq,
                unit: "units"
              )
            )
          ]
        )
      end
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drugs/glargine.rb'
'      def name
        "Glargine"
      end
def name
  "Glargine"
end
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drugs/glargine.rb'
def name
  "Glargine"
end
exit
load 'lib/dm_engine/values/drugs/glargine.rb'
include DmEnginel
include DmEngine
Drugs::Glargine.new
g = Drugs::Glargine.new
g.drug_class
g.drug_type
require "bigdecimal"
BigDecimal.new("infinity")
BigDecimal.new("Infinity")
BigDecimal.new("Infinity".upcase)
BigDecimal::INFINITY
require "dm_engine/values/dose"
require "dm_engine/values/dosing"
require "dm_engine/values/dosing_schedule"
d = DosingSchedule.new(
  [
dose = Dose.build number_of_atoms: 2, atom_denomination: 5, unit: "foo"
dosing = Dosing.new time: "time", dose: dose
ds = DosingSchedule.new([dosing])
ds.restrict_daily_dose_to(dose)
ds.dup
Math.random
ls Math
ls Float
whence #random
ls Numeric
Random
Random.new.rand(0..8.0)
[5] - 5
[5] - [5]
[6] - [5]
[5.0] - [5]
def rand_gt_eight
  r = Random.new.rand(8.0..20)
  rand_gt_eight if r == 8
  r
end
def rand_gt_eight
  r = Random.new.rand(8.0..20)
  rand_gt_eight if r == 8
  r
end
def rand_gt_eight
  r = Random.new.rand(8.0..20)
  rand_gt_eight if r == 8
  r
end
def rand_gt_eight
  r = Random.new.rand(8.0..20)
  rand_gt_eight if r == 8
  r
end
rand_gt_eight
exit
"test"
pry-theme try solarized
exit
downcase.to_s.gsub(/\b('?\S)/u) { "dog" }
require "unicode"
"dog".downcase.to_s.gsub(/\b('?\S)/u)
"dog".downcase.to_s.gsub(/\b('?\S)/u) { $1 }
"dog_cat".downcase.to_s.gsub(/\b('?\S)/u) { $1.upcase }
"dog_cat".split("-").map { |s| s.downcase.capitalize }.join
"dog_cat".split("_").map { |s| s.downcase.capitalize }.join
"doG_CAt".split("_").map { |s| s.downcase.capitalize }.join
2.5r.round
2.5r.floor
25.73r.floor
? Fixnum.floor
? Numeric.floor
whence floor
whence #floor
? Numeric#floor
? Fixnum#floor
? Float#floor
def reload_all
`find ./lib -name '*.rb'`.split.map { |f| f.split("/")[2..-1] }
`find ./lib -name '*.rb'`.split.map { |f| f.split("/")[2..-1].join }
`find ./lib -name '*.rb'`.split.map { |f| f.split("/")[2..-1].join("/") }
exceptions = [
  "dm_engine/logic/glucose/adjust_basal_insulin.rb",
  "dm_engine/logic/glucose/adjust_insulin.rb",
  "dm_engine/logic/glucose/adjust_fast_acting_insulin.rb"
]
def load_all exceptions
  `find ./lib -name '*.rb'`.split.map { |f| f.split("/")[2..-1].join("/") }.each { |f| load f unless exceptions.include?(f) }
end
load_all
edit load_all
reload_all exceptions
exceptions << "dm_engine/use_cases/request_model_parser.rb"
exceptions.pop
exceptions << "dm_engine/use_cases/"
edit reload_all
"dog".match("d")
"dog".match("f")
reload_all
reload_all exceptions
exceptions << "dm_engine/values/step_datum.rb"
exceptions << "dm_engine/treatment/treatments/treatment.rb"
reload_all exceptions
edit reload_all
reload_all exceptions
include DmEngine
c = Comorbidities.new a1c: 7
reload_all exceptions
c = Comorbidities.new a1c: 7
@load_exceptions = exceptions
edit reload_all
Drugs::Glargine.initial_dosings_for c
reload_all exceptions
edit reload_all
reload_all exceptions
c = Comorbidities.new a1c: 7, mass_in_kilograms: 10
c.mass_in_kilograms
c.weight_in_pounds
c.height_in_inches
c.height_in_meters
reload_all exceptions
c = Comorbidities.new a1c: 7, mass_in_kilograms: 10
c.mass_in_kilograms
c.weight_in_pounds
c.weight_in_pounds.to_f
require "bigdecimal"
BigDecimal.new c.weight_in_pounds
BigDecimal.new c.weight_in_pounds, 16
BigDecimal.new c.weight_in_pounds, 25
c.instance_variable_set :@height_in_inches = 72
c.instance_variable_set :@height_in_inches, 72
x.height_in_inches
c.height_in_inches
c.instance_variable_set :@height_in_inches, 72.0r
c.height_in_inches
c.height_in_meters
c.height_in_meters.to_s
c.height_in_meters.to_f
Drugs::Glargine.initial_dosings_for c
reload_all exceptions
Drugs::Glargine.initial_dosings_for c
c2 = Comorbidities.new a1c: 8, mass_in_kilograms: 10
Drugs::Glargine.initial_dosings_for c2
c2 = Comorbidities.new a1c: 8, mass_in_kilograms: 20
Drugs::Glargine.initial_dosings_for c2
c3 = Comorbidities.new a1c: 8.1r, mass_in_kilograms: 10
Drugs::Glargine.initial_dosings_for c3
reload_all exceptions
Drugs::Glargine.initial_dosings_for c3
c4 = Comorbidities.new a1c: 8.1r, mass_in_kilograms: 100
Drugs::Glargine.initial_dosings_for c4
c5 = Comorbidities.new a1c: 8r, mass_in_kilograms: 100
Drugs::Glargine.initial_dosings_for c5
reload_all exceptions
c1
c
Drugs::Glargine.initial_dosings_for c
reload_all exceptions
Drugs::Glargine.initial_dosings_for c
reload_all exceptions
Drugs::Glargine.initial_dosings_for c
c2
Drugs::Glargine.initial_dosings_for c2
c3
Drugs::Glargine.initial_dosings_for c3
c4
Drugs::Glargine.initial_dosings_for c4
c5
Drugs::Glargine.initial_dosings_for c5
[1, 2].join(" - ")
reload_all exceptions
Drugs::Glargine.initial_dosings_for c5
ls Array
Drugs::Glargine.initial_dosings_for c5
reload_all exceptions
c
Drugs::Glargine.initial_dosings_for c
Drugs::Glargine.initial_dosings_for c2
Drugs::Glargine.initial_dosings_for c3
reload_all exceptions
Drugs::Glargine.initial_dosings_for c
reload_all exceptions
Drugs::Glargine.initial_dosings_for c
reload_all exceptions
Drugs::Glargine.initial_dosings_for c
Drugs::Glargine.initial_dosings_for c2
Drugs::Glargine.initial_dosings_for c3
reload_all exceptions
Drugs::Glargine.initial_dosings_for c
Drugs::Glargine.initial_dosings_for c2
Drugs::Glargine.initial_dosings_for c3
reload_all exceptions
Drugs::Glargine.initial_dosings_for c
Drugs::Glargine.initial_dosings_for c2
Drugs::Glargine.initial_dosings_for c3
Drugs::Glargine.initial_dosings_for c4
Drugs::Glargine.initial_dosings_for c5
toggle-color
Drugs::Glargine.initial_dosings_for c5
exit
component
acc_plan
continue
component
acc_plan
continue
component
acc_plan
!!!
component
acc_plan
continue
component
acc_plan
continue
component
acc_plan
continue
component
acc_plan
!!!
component
acc_plan
continue
component
acc_plan
continue
component
acc_plan
continue
component
acc_plan
continue
component
acc_plan
continue
acc_plan
component
!!!
acc_plan
component
continue
acc_plan
component
continue
acc_plan
component
continue
acc_plan
component
continue
acc_plan
component
continue
acc_plan
!!!
acc_plan
component
continue
acc_plan
component
continue
acc_plan
component
continue
acc_plan
component
continue
acc_plan
component
component.run pt: pt, plan: acc_plan, treatment_type: treatment_type, drug_change_type: drug_change_type, drug_opt_lists: drug_opt_lists
continue
finish
continue
datum
!!!
datum
!!!
datum
DrugFilter.new.run(*datum)
step
pt
plan
treatment_type
drug_change_type
drug_opt_lists
ls
drug_filters
filter drug_opt_lists, pt
!!!
exit
"test"
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drugs/glargine.rb'
include DmEngine
ls Drugs::Glargine
ls Drug::Drug
ls Drugs::Drug
g = Drugs::Glargine.new
g.daily_dose_does_not_exceed_max?
g = Drugs::Glargine.new dosings: DosingSchedule.new([Dosing.new(time: "time", dose: Dose.build(amount: 15, unit: "units"))])
g.daily_dose_does_not_exceed_max?
_e_
__e__
_
_e
e_
e*
g
g.dosing_schedule
g.dosing_schedule.dosings
g.dosing_schedule.dosings.dose
g.dosing_schedule.dosings.to_a.first
g.dosing_schedule.dosings.to_a.first.dose
ls g.dosing_schedule.dosings.to_a.first.dose
g.daily_dose_does_not_exceed_max?
g
g.max_daily_dose
g = Drugs::Glargine.new dosings: DosingSchedule.new([Dosing.new(time: "time", dose: Dose.build(amount: 15, unit: "units"))]), max_daily_dose: Drugs::Glargine.normal_max_daily_dose
g.daily_dose_does_not_exceed_max?
load 'lib/dm_engine/values/drugs/insulin.rb'
g = Drugs::Glargine.new dosings: DosingSchedule.new([Dosing.new(time: "time", dose: Dose.build(amount: 15, unit: "units"))]), max_daily_dose: Drugs::Glargine.normal_max_daily_dose
g.daily_dose_does_not_exceed_max?
g = Drugs::Glargine.new dosings: DosingSchedule.new([Dosing.new(time: "time", dose: Dose.build(amount: 15, unit: "units"))])
g.daily_dose_does_not_exceed_max?
require "dm_engine/values/comorbidities"
c = Comorbidities.new a1c: @a1c_eight,
creatinine: 1,
is_on_dialysis: true,
is_elderly_or_frail: false,
gender: "male",
gfr: 100,
has_liver_disease: false,
mass_in_kilograms: @one_hundred_kilograms
@a1c_eight = 8
@one_hundred_kilograms = 100
c
c = Comorbidities.new a1c: @a1c_eight,
creatinine: 1,
is_on_dialysis: true,
is_elderly_or_frail: false,
gender: "male",
gfr: 100,
has_liver_disease: false,
mass_in_kilograms: @one_hundred_kilograms
ls c
require "dm_engine/values/drugs"
glim = Drugs::Glimepiride.new dosings: Drugs::Glimepiride.initial_dosings_for(c), max_daily_dose: Drugs::Glimepiride.max_daily_dose_for(c)
c
c.dialysis?
$ Drugs::Glimepiride.max_daily_dose_for
def summary_of drug_change_type, drug_opt_lists
  "#{drug_change_type.capitalize} #{drug_opt_lists.first.first.drug_class}."
end
g
drug_opt_lists = [
  [g]
]
summary_of "start", drug_opt_lists
ls
drug_opt_lists = [
  [glim], [g]
]
summary_of "start", drug_opt_lists
drug_opt_lists = [
  [g, glim], [glim, g]
]
summary_of "start", drug_opt_lists
:a.capitalize
load 'lib/dm_engine/treatment/plan_makers/treatment_summary_adder.rb'
summary_of "start", drug_opt_lists
$ summary_of
Treatment::PlanMakers::TreatmentSummaryAdder.new.summary_of drug_change_type, drug_opt_lists
Treatment::PlanMakers::TreatmentSummaryAdder.new.summary_of "start", drug_opt_lists
$ Treatment::PlanMakers::TreatmentSummaryAdder#summary_of
# private
def summary_of drug_change_type, drug_opt_lists
  "#{drug_change_type.capitalize} #{drug_opt_lists.first.first.drug_class}."
end
def summary_of drug_change_type, drug_opt_lists
  "#{drug_change_type.capitalize} #{drug_opt_lists.first.first.drug_class}."
end
summary_of "start", drug_opt_lists
# private
def summary_of drug_change_type, drug_opt_lists
  "#{drug_change_type.capitalize} #{drug_opt_lists.first.first.drug_class}."
end
# private
def summary_of drug_change_type, drug_opt_lists
  "#{drug_change_type.capitalize} #{drug_opt_lists.first.first.drug_class}."
end
def summary_of drug_change_type, drug_opt_lists
  "#{drug_change_type.capitalize} #{drug_opt_lists.first.first.drug_class}."
end
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/treatment/plan_makers/summary_adder.rb'
Treatment::PlanMakers::SummaryAdder.new.run(
  pt: "pt",
require "dm_engine/values/plan"
Treatment::PlanMakers::SummaryAdder.new.run(
  pt: "pt",
  plan: Plan.new,
  treatment_type: "glucose",
  drug_change_type: "start",
  drug_opt_lists: [[g],[glim]]
)
load 'lib/dm_engine/treatment/plan_makers/continued_drugs_adder.rb'
Treatment::PlanMakers::ContinuedDrugsAdder.new.run(
  pt: "pt",
  plan: Plan.new,
  treatment_type: "glucose",
  drug_change_type: "start",
  drug_opt_lists: [[g],[glim]]
)
require "dm_engine/values/patient"
pt = Patient.new ok_drugs: [glim]
help
hist
hist.reverse
hist
Treatment::PlanMakers::ContinuedDrugsAdder.new.run(
  pt: pt,
  plan: Plan.new,
  treatment_type: "glucose",
  drug_change_type: "start",
  drug_opt_lists: [[g], [glim]]
)
Treatment::PlanMakers::ContinuedDrugsAdder.new.run(
  pt: pt,
  plan: Plan.new(
    treatment_type: "glucose",
    summary: "summary",
    instructions: ["instructions"],
  )
  ,
Treatment::PlanMakers::ContinuedDrugsAdder.new.run(
  pt: pt,
  plan: Plan.new(
    treatment_type: "glucose",
    summary: "summary",
    instructions: ["instructions"],
  ),
  treatment_type: "glucose",
  drug_change_type: "start",
  drug_opt_lists: [[g], [glim]]
)
load 'lib/dm_engine/values/plan.rb'
hist
hist[2953..2963]
hist --replay 2953..2963
pry-theme try pry-classic
pry-theme try "pry-classic"
pry-theme try pry-classic256
pry-theme try pry-classic-256
Float.ancestors
Fixnum.ancestors
BigDecimal.ancestors
Rational.ancestors
def self.max_daily_dose_for comorbidities
  c = comorbidities
  errors = []
  case
  when c.gender.downcase != "male" || c.gender.downcase != "female"
    errors << "gender must be 'male' or 'female'"
  when !c.creatinine.kind_of?(Numeric) || c.creatinine < 0
    errors << "creatinine must be a non-negative number"
  when c.liver_disease?.nil?
    errors << "liver disease must be true or false"
  end
  raise ArgumentError, errors.join(", ") unless errors.empty?
def self.max_daily_dose_for comorbidities
  c = comorbidities
  errors = []
  case
  when c.gender.downcase != "male" || c.gender.downcase != "female"
    errors << "gender must be 'male' or 'female'"
  when !c.creatinine.kind_of?(Numeric) || c.creatinine < 0
    errors << "creatinine must be a non-negative number"
  when c.liver_disease?.nil?
    errors << "liver disease must be true or false"
  end
  raise ArgumentError, errors.join(", ") unless errors.empty?
  if c.liver_disease? ||
    (c.gender == "female" && c.creatinine > 1.3r) ||
    (c.gender == "male" && c.creatinine > 1.5r)
    normal_max_daily_dose * 0
  else
    normal_max_daily_dose
  end
end
c
oad 'lib/dm_engine/values/drugs/metformin_er.rb'
load 'lib/dm_engine/values/drugs/metformin_er.rb'
Drugs::MetforminER.max_daily_dose_for c
c.gender
c.gender.downcase
c.gender.downcase != "male"
c.gender.downcase == "male"
c.gender.downcase != "male"
c.gender.downcase != "female"
load 'lib/dm_engine/values/drugs/metformin_er.rb'
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@gender, "foo"
Drugs::MetforminER.max_daily_dose_for c
load 'lib/dm_engine/values/drugs/metformin_er.rb'
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@gender, "female"
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@creatinine, nil
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@creatinine, -1
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@creatinine, "1"
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@creatinine, 1
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@liver_disease, nil
Drugs::MetforminER.max_daily_dose_for c
TrueClass
true.class
false.class
"f" == true
"f" === true
!!"f"
load 'lib/dm_engine/values/drugs/metformin_er.rb'
Drugs::MetforminER.max_daily_dose_for c
c
c.instance_variable_set :@liver_disease, "truthy"
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@liver_disease, false
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@liver_disease, true
Drugs::MetforminER.max_daily_dose_for c
c.instance_variable_set :@liver_disease, nil
c.instance_variable_set :@gender, nil
c.instance_variable_set :@creatinine, nil
Drugs::MetforminER.max_daily_dose_for c
load 'lib/dm_engine/values/drugs/metformin_er.rb'
Drugs::MetforminER.max_daily_dose_for c
load 'lib/dm_engine/values/drugs/metformin_er.rb'
Drugs::MetforminER.max_daily_dose_for c
load 'lib/dm_engine/values/drugs/metformin_er.rb'
Drugs::MetforminER.max_daily_dose_for c
load 'lib/dm_engine/values/drugs/metformin_er.rb'
Drugs::MetforminER.max_daily_dose_for c
[1, 2, 3].second
load 'test/treatment/test_treatment_implementer.rb'
load 'lib/dm_engine/values/drugs/non_maxable_drug.rb'
load 'lib/dm_engine/values/drugs/basal_insulin.rb'
load 'lib/dm_engine/values/drugs/glargine.rb'
exit
load 'lib/dm_engine/values/drugs/glargine.rb'
include DmEngine
ls Drugs::Glargine
g = Drugs::Glargine.new
ls g
g.singleton_methods
Drugs::Glargine.singleton_methods
load 'lib/dm_engine/values/drugs/glargine.rb'
Drugs::Glargine.singleton_methods
g = Drugs::Glargine.new
ls g
ls Drugs::Glargine
load 'lib/dm_engine/values/drugs/glargine.rb'
ls Drugs::Glargine
g = Drugs::Glargine.new
ls g
Drugs::Glargine.normal_max_daily_dose
load 'lib/dm_engine/values/drugs/non_maxable_drug.rb'
load 'lib/dm_engine/values/drugs/glargine.rb'
ls Drugs::Glargine
load 'lib/dm_engine/values/drugs/non_maxable_drug.rb'
load 'lib/dm_engine/values/drugs/glargine.rb'
ls Drugs::Glargine
ls Module
$ Module.include
oad 'lib/dm_engine/values/drugs/drug.rb'
load 'lib/dm_engine/values/drugs/drug.rb'
load 'lib/dm_engine/values/drugs/glargine.rb'
c
load "lib/dm_engine/values/comorbidities"
load "lib/dm_engine/values/comorbidities.rb"
c = Comorbidites.new
c = Comorbidities.new
Drugs::Glargine.start_for c
load 'lib/dm_engine/values/drugs/drug.rb'
Drugs::Glargine.start_for c
load 'lib/dm_engine/values/drugs/glargine.rb'
Drugs::Glargine.start_for c
load 'lib/dm_engine/values/drugs/drug.rb'
load 'lib/dm_engine/values/drugs/glargine.rb'
Drugs::Glargine.start_for c
c = Comorbidities.new a1c: 8
Drugs::Glargine.start_for c
load 'lib/dm_engine/values/drugs/drug.rb'
Drugs::Glargine.start_for c
step
comorbidities
step
@weight_in_pounds
mass_in_kilograms
exit
c = Comorbidities.new a1c: 8, mass_in_kilograms: 100
Drugs::Glargine.start_for c
continue
Array.singleton_class
Array.class
[].class
exit
load 'lib/dm_engine/data_access/in_memory_drug_repository.rb'
include DmEngine
include DataAccess
load "lib/dm_engine/values/comorbidities.rb"
c = Comorbidities.new gender: "male", creatinine: 1r, has_liver_disease: false
InMemoryDrugRepository.start_metformins c
load 'lib/dm_engine/data_access/in_memory_drug_repository.rb'
InMemoryDrugRepository.start_metformins c
load 'lib/dm_engine/data_access/in_memory_drug_repository.rb'
InMemoryDrugRepository.start_metformins c
load 'lib/dm_engine/data_access/in_memory_drug_repository.rb'
InMemoryDrugRepository.start_metformins c
load 'lib/dm_engine/data_access/in_memory_drug_repository.rb'
InMemoryDrugRepository.start_metformins c
load 'lib/dm_engine/data_access/in_memory_drug_repository.rb'
InMemoryDrugRepository.start_metformins c
require "lib/dm_engine/values/incrementable_maxable_drug"
require "dm_engine/values/incrementable_maxable_drug"
include DmEngine
InMemoryDrugRepository.start_metformins c
exit
drug
comorbidities
df
drug_functions
df = drug_functions[drug[:name]]
continue
df
continue
df
continue
pt
plan
change_drugs_lists
combinations_of(drug_opt_lists_from(*change_drugs_lists))
continue
change
change_drugs_lists
combinations_of(drug_opt_lists_from(*change_drugs_lists))
drug_opt_lists_from(*change_drugs_lists)
change_drugs_lists
whereami
up
start_non_metformin_non_insulin_glucose_drug_for(pt)
whereami
down
change_drugs_lists
whereami
drug_opt_lists_from(*change_drugs_lists)
whereami
exit
!!!
drug_opt_lists_from(change_drugs_lists)
continue
drug_opt_lists_from(change_drugs_lists)
whereami
next
previous
back
!!!
continue
next
step
change_drugs_lists
whereami
change_drugs_lists.map { |list| list[1..-1] }
whereami
!!!
gem-cd minitest
ls
Assertions
exit
acc_plan_drugs_lists
step
acc_plan_drugs
step
acc_plan_drugs
acc_plan_drugs.first
acc_plan_drugs.last
next
continue
acc_plan_drugs_lists
!!!
step
acc_plan_drugs
send component, acc_plan_drugs.first, acc_plan_drugs.last, comorbidities
!!!
1955058166950033286674947/81935320000000000000000
BigDecimal::INFINITY
require "bigdecimal"
BigDecimal::INFINITY
? Enumerable#group_by
? Enumerable#partition
require "set"
Set["a", "b", "c"] - Set["a"]
Set["a", "b", "c"] - "a"
["a", "b", "c"] - "a"
def cs drugs
  drugs.map { |drug|
    [
      [drug],
      (drugs - [drug]).select { |other_drug|
        DrugConflict.conflict_between? drug, other_drug
      }
    ]
  }.flat_map { |drug_conflicting_drugs|
    drug_conflicting_drugs.first.product drug_conflicting_drugs.last
  }
end
require "dm_engine/services/drug_service"
metformin_er = @ds.make_drug(
  name: "Metformin ER",
  dosings: [
    {
      time: "pm",
      dose: {
        atom_denomination: 500,
        number_of_atoms: 4,
        unit: "mg"
      }
    }
  ],
  comorbidities: c
)
c = Comorbidities.new creatinine: 1,
is_on_dialysis: true,
is_elderly_or_frail: false,
gender: "male",
has_liver_disease: true
require "dm_engine/values/comorbidities"
c = Comorbidities.new creatinine: 1,
is_on_dialysis: true,
is_elderly_or_frail: false,
gender: "male",
has_liver_disease: true
include DmEngine
c = Comorbidities.new creatinine: 1,
is_on_dialysis: true,
is_elderly_or_frail: false,
gender: "male",
has_liver_disease: true
metformin_er = @ds.make_drug(
  name: "Metformin ER",
  dosings: [
    {
      time: "pm",
      dose: {
        atom_denomination: 500,
        number_of_atoms: 4,
        unit: "mg"
      }
    }
  ],
  comorbidities: c
)
@ds = Services::DrugService
metformin_er = @ds.make_drug(
  name: "Metformin ER",
  dosings: [
    {
      time: "pm",
      dose: {
        atom_denomination: 500,
        number_of_atoms: 4,
        unit: "mg"
      }
    }
  ],
  comorbidities: c
)
exenatide = @ds.make_drug(
  name: "Exenatide",
  dosings: [
    {
      time: "am",
      dose: {
        amount: 10,
        unit: "mcg"
      }
    },
    {
      time: "pm",
      dose: {
        amount: 10,
        unit: "mcg"
      }
    }
  ],
  comorbidities: c
)
c
c = Comorbidities.new creatinine: 1, is_on_dialysis: false, is_elderly_or_frail: false, gender: "male", gfr: 100, has_liver_disease: false, a1c: 8, mass_in_kg: 100, height_in_inches: 72
c = Comorbidities.new creatinine: 1, is_on_dialysis: false, is_elderly_or_frail: false, gender: "male", gfr: 100, has_liver_disease: false, a1c: 8, mass_in_kg: 100, height_in_in: 72
metformin_er = @ds.make_drug(
  name: "Metformin ER",
  dosings: [
    {
      time: "pm",
      dose: {
        atom_denomination: 500,
        number_of_atoms: 4,
        unit: "mg"
      }
    }
  ],
  comorbidities: c
)
exenatide = @ds.make_drug(
  name: "Exenatide",
  dosings: [
    {
      time: "am",
      dose: {
        amount: 10,
        unit: "mcg"
      }
    },
    {
      time: "pm",
      dose: {
        amount: 10,
        unit: "mcg"
      }
    }
  ],
  comorbidities: c
)
saxagliptin = @ds.make_drug(
  name: "Saxagliptin",
  dosings: [
    {
      time: "d",
      dose: {
        atom_denomination: 5,
        number_of_atoms: 1,
        unit: "mg"
      }
    }
  ],
  comorbidities: c
)
cs [metformin_er, exenatide, saxagliptin]
require "dm_engine/treatment/drug_conflict"
cs [metformin_er, exenatide, saxagliptin]
include DmEngine::Treatment
cs [metformin_er, exenatide, saxagliptin]
def cs drugs
  drugs.map { |drug|
    [
      [drug],
      (drugs - [drug]).select { |other_drug|
        Treatment::DrugConflict.conflict_between? drug.drug_class, other_drug.drug_class
      }
    ]
  }.flat_map { |drug_conflicting_drugs|
    drug_conflicting_drugs.first.product drug_conflicting_drugs.last
  }
end
cs [metformin_er, exenatide, saxagliptin]
require "util"
def cs drugs
  Util.as_sets(
    drugs.map { |drug|
      [
        [drug],
        (drugs - [drug]).select { |other_drug|
          Treatment::DrugConflict.conflict_between? drug.drug_class, other_drug.drug_class
        }
      ]
    }.flat_map { |drug_conflicting_drugs|
      drug_conflicting_drugs.first.product drug_conflicting_drugs.last
    }
  )
end
cs [metformin_er, exenatide, saxagliptin]
edit cs
cs [metformin_er, exenatide, saxagliptin]
Set["a", "b"].product Set["c", d", "e"]
Set["a", "b"].product Set["c", "d", "e"]
["a", "b"].product ["c", "d", "e"]
["a", "b"].product ["c", "d"], ["e", "f"], ["g", "h"]
def ok_subsets drugs
  first, *rest = 
  *Util.as_nested_sets(
    drugs.map { |drug|
      [
        [drug],
        (drugs - [drug]).select { |other_drug|
          Treatment::DrugConflict.conflict_between?(
            drug.drug_class,
            other_drug.drug_class
          )
        }
      ]
    }.flat_map { |drug_conflicting_drugs|
      drug_conflicting_drugs.first.product drug_conflicting_drugs.last
    }
  ).map { |conflicting_set| Array(conflicting_set) }
  first.product(*rest)
end
ok_subsets [metformin_er, exenatide, saxagliptin]
def branch_on_conflict datum
  # For each drug, get the set of conflicting drugs.
  # Since conflict is reflexive but not transitive, take the product of each
  #   drug with its set of conflicting drugs.
  # The union of such product sets is the set of drug conflicts.
  # The product of elements of the set of drug conflicts is the set of conflict-free
  #   subsets of drugs.
  # For each conflict-free subset, make a plan with all other drugs stopped.
  plan, drugs, comorbidities = *datum
  first, *rest = 
  *Util.as_nested_sets(
    drugs.map { |drug|
      [
        [drug],
        (drugs - [drug]).select { |other_drug|
          Treatment::DrugConflict.conflict_between?(
            drug.drug_class,
            other_drug.drug_class
          )
        }
      ]
    }.flat_map { |drug_conflicting_drugs|
      drug_conflicting_drugs.first.product drug_conflicting_drugs.last
    }
  ).map { |conflicting_set| Array(conflicting_set) }
  first.product(*rest).map { |conflict_free_drugs|
    plan.add_drugs_to_stop(
      drugs - conflict_free_drugs
    )
  }
end
def branch_on_conflict datum
  # For each drug, get the set of conflicting drugs.
  # Since conflict is reflexive but not transitive, take the product of each
  #   drug with its set of conflicting drugs.
  # The union of such product sets is the set of drug conflicts.
  # The product of elements of the set of drug conflicts is the set of conflict-free
  #   subsets of drugs.
  # For each conflict-free subset, make a plan with all other drugs stopped.
  plan, drugs, comorbidities = *datum
  set_of_drug_conflicts = 
  Util.as_nested_sets(
    drugs.map { |drug|
      [
        [drug],
        (drugs - [drug]).select { |other_drug|
          Treatment::DrugConflict.conflict_between?(
            drug.drug_class,
            other_drug.drug_class
          )
        }
      ]
    }.flat_map { |drug_conflicting_drugs|
      drug_conflicting_drugs.first.product drug_conflicting_drugs.last
    }
  ).map { |conflicting_set| Array(conflicting_set) }
  set_of_drug_conflicts.first.product(set_of_drug_conflicts[1..-1])
  .map { |conflict_free_drugs|
    plan.add_drugs_to_stop(
      set_of_drug_conflicts.flatten - conflict_free_drugs
    )
  }
end
branch_on_conflict Plan.new, [metformin_er, saxagliptin, exenatide], c
require "dm_engine/values/plan"
branch_on_conflict Plan.new, [metformin_er, saxagliptin, exenatide], c
branch_on_conflict [Plan.new, [metformin_er, saxagliptin, exenatide], c]
def cs drugs
  Util.as_nested_sets(
    drugs.map { |drug|
      [
        [drug],
        (drugs - [drug]).select { |other_drug|
          Treatment::DrugConflict.conflict_between?(
            drug.drug_class,
            other_drug.drug_class
          )
        }
      ]
    }.flat_map { |drug_conflicting_drugs|
      drug_conflicting_drugs.first.product drug_conflicting_drugs.last
    }
  ).map { |conflicting_set| Array(conflicting_set) }
end
cs [metformin_er, exenatide, saxagliptin]
def cs drugs
  set_of_drug_conflicts = 
  Util.as_nested_sets(
    drugs.map { |drug|
      [
        [drug],
        (drugs - [drug]).select { |other_drug|
          Treatment::DrugConflict.conflict_between?(
            drug.drug_class,
            other_drug.drug_class
          )
        }
      ]
    }.flat_map { |drug_conflicting_drugs|
      drug_conflicting_drugs.first.product drug_conflicting_drugs.last
    }
  ).map { |conflicting_set| Array(conflicting_set) }
  set_of_drug_conflicts.first.product(set_of_drug_conflicts[1..-1])
end
cs [metformin_er, exenatide, saxagliptin]
edit cs
cs [metformin_er, exenatide, saxagliptin]
step
next
!!!
set_of_drug_conflicts
whereami
set_of_drug_conflicts.first.product(*set_of_drug_conflicts[1..-1])
!!!
set_of_drug_conflicts
whereami
set_of_drug_conflicts.first.product(*set_of_drug_conflicts[1..-1])
whereami
next
step
conflict_free_drugs
set_of_drug_conflicts.flatten - conflict_free_drugs
whereami
up
!!!
plans
whereami
!!!
datums
whereami
next
data
whereami
step
plan
step
plan
drug
whereami
drugs
!!!
r
!!!
r
!!!
continue
r
!!!
r
!!!
continue
r
continue
r
continue
r
continue
r
continue
edit cs
cs [metformin_er, exenatide, saxagliptin]
set_of_drug_conflicts
set_of_drug_conflicts.first
set_of_drug_conflicts.last
whereami
set_of_drug_conflicts.first.product(set_of_drug_conflicts[1..-1])
set_of_drug_conflicts[1..-1]
["a", "b", "c"].product []
["a", "b", "c"].product
first, *rest = set_of_drug_conflicts
first.product(*rest)
set_of_drug_conflicts.first.product(*set_of_drug_conflicts[1..-1])
def branch_on_conflict datum
  # For each drug, get the set of conflicting drugs.
  # Since conflict is reflexive but not transitive, take the product of each
  #   drug with its set of conflicting drugs.
  # The union of such product sets is the set of drug conflicts.
  # The product of elements of the set of drug conflicts is the set of conflict-free
  #   subsets of drugs.
  # For each conflict-free subset, make a plan with all other drugs stopped.
  plan, drugs, comorbidities = *datum
  set_of_drug_conflicts = 
  Util.as_nested_sets(
    drugs.map { |drug|
      [
        [drug],
        (drugs - [drug]).select { |other_drug|
          Treatment::DrugConflict.conflict_between?(
            drug.drug_class,
            other_drug.drug_class
          )
        }
      ]
    }.flat_map { |drug_conflicting_drugs|
      drug_conflicting_drugs.first.product drug_conflicting_drugs.last
    }
  ).map { |conflicting_set| Array(conflicting_set) }
  set_of_drug_conflicts.first.product(*set_of_drug_conflicts[1..-1])
  .map { |conflict_free_drugs|
    plan.add_drugs_to_stop(
      set_of_drug_conflicts.flatten - conflict_free_drugs
    )
  }
end
hist
hist --tail
hist --tail 100
branch_on_conflict [Plan.new, [metformin_er, saxagliptin, exenatide], c]
metformin_er
saxagliptin
branch_on_conflict
saxagliptin = @ds.make_drug(
  name: "Saxagliptin",
  dosings: [
    {
      time: "d",
      dose: {
        atom_denomination: 5,
        number_of_atoms: 1,
        unit: "mg"
      }
    }
  ],
  comorbidities: c
)
c = Comorbidities.new creatinine: 1,
is_on_dialysis: false,
is_elderly_or_frail: false,
gender: "male",
gfr: 100,
has_liver_disease: false
@ds.make_drug(
  name: "Metformin ER",
  dosings: [
    {
      time: "pm",
      dose: {
        atom_denomination: 500,
        number_of_atoms: 4,
        unit: "mg"
      }
    }
  ],
  comorbidities: c
)    metformin_er = @ds.make_drug(
name: "Metformin ER",
dosings: [
{
  time: "pm",
  dose: {
    atom_denomination: 500,
    number_of_atoms: 4,
    unit: "mg"
  }
}
],
comorbidities: c
)
exenatide = @ds.make_drug(
  name: "Exenatide",
  dosings: [
    {
      time: "am",
      dose: {
        amount: 10,
        unit: "mcg"
      }
    },
    {
      time: "pm",
      dose: {
        amount: 10,
        unit: "mcg"
      }
    }
  ],
  comorbidities: c
)
saxagliptin = @ds.make_drug(
  name: "Saxagliptin",
  dosings: [
    {
      time: "d",
      dose: {
        atom_denomination: 5,
        number_of_atoms: 1,
        unit: "mg"
      }
    }
  ],
  comorbidities: c
)
branch_on_conflict [Plan.new, [metformin_er, saxagliptin, exenatide], c]
metformin_er = @ds.make_drug(
  name: "Metformin ER",
  dosings: [
    {
      time: "pm",
      dose: {
        atom_denomination: 500,
        number_of_atoms: 4,
        unit: "mg"
      }
    }
  ],
  comorbidities: c
)
metformin_er
branch_on_conflict [Plan.new, [metformin_er, saxagliptin, exenatide], c]
Set["a", "b"].first
Set["a", "b"]
Set["a", "b"].last
Set["a", "b"].first
ls Set
Set.ancestors
ls Enumerable
? Enumerable#each_cons
? Enumerable#collect
? Enumerable#collect_concat
? Enumerable#select
$ Enumerable#select
$ Enumerable#reject
Set["a", "b", "c"]
Set["a", "b", "c", "a"]
Set[Set["a", "b", "c", "a"], Set["a", "b", "c", "a"]]
? Array#uniq
$ Array#uniq
$ Array#to_set
["a", "b", "c", "a"].uniq
[["a", "b", "c", "a"].uniq, ["a", "b", "c", "a"].uniq].uniq
Set[Set["a", "b", "c", "a"], Set["a", "b", "c", "a"]]
["a", "b"].uniq
["b", "a"].uniq
["a", "b"].uniq == ["b", "a"].uniq
["a", "b", "a"].uniq == ["b", "a", "b"].uniq
Set[Set["a", "b", "c", "a"], Set["a", "b", "c", "a"]]
*Set[Set["a", "b", "c", "a"], Set["a", "b", "c", "a"]]
first, *rest = *Set[Set["a", "b", "c", "a"], Set["a", "b", "c", "a"]]
first
rest
Set["a", "b" "c"] + "c"
Set["a", "b" "c"] << "c"
Set["a", "b" "c"]
Set["a", "b" "c"] << "c"
Set["a", "b" "c"] << "a"
Set["a", "b" "c"] << "c"
Set["a", "b" "c"] << "b"
Set["a", "b" "c"] << "d"
Set["a", "b" "c"] << 1
? Set#<<
Set[1, 2, 3] << 4
Set["a", "b", "c"] << "d"
Set["a", "b", "c"] << "c"
Set["a", "b", "c"] << "b"
Set["a", "b", "c"] << "a"
Set["a", "b", "c"] << "e"
Set["b", *Set[]]
load '/home/cort/Projects/dm_app/dm_engine/lib/keyword_struct.rb'
TestDef = KeywordStruct.new :type, :name do
  def color
    "gray"
  end
end
dog = TestDef.new type: "dog", name: "rick"
dog.color
e = {:treatment_type=>"glucose", :summary=>"start basal insulin", :instructions=>["Return in 1 - 2 weeks to adjust treatment based on glucose records."], :start_drugs=>[[{:name=>"Glargine", :dosings=>[{:time=>"am", :dose=>{:amount=>[10, 20], :unit=>"units"}}]}, {:name=>"Detemir", :dosings=>[{:time=>"pm", :dose=>{:amount=>[10, 20], :unit=>"units"}}]}]], :stop_drugs=>[], :change_drugs=>[], :continue_drugs=>[]}
a = {:treatment_type=>"glucose", :summary=>"start basal insulin", :instructions=>["Return in 1 - 2 weeks to adjust treatment based on glucose records."], :start_drugs=>[[{:name=>"Detemir", :dosings=>[{:time=>"pm", :dose=>{:amount=>[10, 20], :unit=>"units"}}]}, {:name=>"Glargine", :dosings=>[{:time=>"am", :dose=>{:amount=>[10, 20], :unit=>"units"}}]}]], :stop_drugs=>[], :change_drugs=>[], :continue_drugs=>[]}
e.treatment_type == a.treatment_type
e[:treatment_type] == a[:treatment_type]
e[:summary] == a[:summary]
e[:instructions] == a[:instructions]
e[:start_drugs] == a[:start_drugs]
e[:start_drugs]
a[:start_drugs]
e[:start_drugs].first.first == a[:start_drugs].first.first
e[:start_drugs].first.first
a[:start_drugs].first.first
e[:start_drugs]
e[:start_drugs].first
e[:start_drugs].first.first
e[:start_drugs].first
e[:start_drugs].first.length
e[:start_drugs].first.each { |e| p e }
over_limit_dosing_schedule = DosingSchedule.new [
  Dosing.new(time: "quux", dose: Dose.build(amount: 9, unit: "unit")),
  Dosing.new(time: "sneh", dose: Dose.build(amount: 12, unit: "unit"))
]
limit_dose = Dose.build amount: 14, unit: "unit"
restricted_dosing_schedule = DosingSchedule.new [
  Dosing.new(time: "quux", dose: Dose.build(amount: 6, unit: "unit")),
  Dosing.new(time: "sneh", dose: Dose.build(amount: 8, unit: "unit"))
]
r = over_limit_dosing_schedule.restrict_daily_dose_to(limit_dose)
r
r.dosings.to_a.first.dose.amount
restricted_dosing_schedule.dosings.to_a.first.dose.amount
6r == 6
r.dosings.to_a.first.dose == restricted_dosing_schedule.dosings.to_a.first.dose
r == restricted_dosing_schedule
r.dosings.to_a.last.dose == restricted_dosing_schedule.dosings.to_a.last.dose
r
restricted_dosing_schedule
r.dosings = restricted_dosing_schedule.dosigns
r.dosings = restricted_dosing_schedule.dosings
r.dosings
restricted_dosing_schedule.dosings
r.dosisngs == restricted_dosing_schedule.dosings
r.dosings == restricted_dosing_schedule.dosings
rd = r.dosings
ard = r.dosings
erd = restricted_dosing_schedule.dosings
ard == erd
ard.each |dosing| p dosing; puts }
ard.each { |dosing| p dosing; puts }
erd.each { |dosing| p dosing; puts }
r.first
ard.first
erd.first
ard.first.dose == erd.first.dose
ard = erd
ard = r.dosings
ard == erd
ard.hash
erd.hash
dosing_schedule = DosingSchedule.new [
  Dosing.new(
    time: "time",
    dose: Dose.build(
      atom_denomination: 1.5r,
      number_of_atoms: 2,
      unit: "unit"
    )
  ),
  Dosing.new(
    time: "other time",
    dose: Dose.build(
      atom_denomination: 2,
      number_of_atoms: 1,
      unit: "unit"
    )
  )
]
equal_dosing_schedule = DosingSchedule.new(nil)
def equal_dosing_schedule.dosings
  Set[
    Dosing.new(
      time: "time",
      dose: Dose.build(
        atom_denomination: 1.5r,
        number_of_atoms: 2,
        unit: "unit"
      )
    ),
    Dosing.new(
      time: "other time",
      dose: Dose.build(
        atom_denomination: 2,
        number_of_atoms: 1,
        unit: "unit"
      )
    )
  ]
end
dosing_schedule == equal_dosing_schedule
dosing_schedule.== equal_dosing_schedule
dosing_schedule.eql? equal_dosing_schedule
dosing_schedule.hash
equal_dosing_schedule.hash
dosing_schedule.dosings.hash
equal_dosing_schedule.dosings.hash
nil.to_r
[1, 2] * 2
%q the dog ran around %
%q the dog ran around q
q%the dog ran around%
%qthe dog ran around%
%qthe dog ran aroundq
%q the dog ran around q
%q the dog ran around %q
%Q(the dog ran around)
%Q(the dog ran around #{Time.now})
%q(the dog ran around #{Time.now})
%[the dog ran around]
%[the dog ran around #{Time.now}]
%Q(the dog ran around #{Time.now} "per se")
%(the dog ran around #{Time.now} "per se")
%q(the dog ran around #{Time.now} "per se")
exit
0.5r.to_s
0.5r.to_f.to_s
0.5r.to_f
gem list
.gem list
exit
? Array#concat
exit
h = [
  {
    name: "rick",
    color; "grayish",
h = [
  {
    name: "Rick",
    color: "grayish",
    food: "rib bones",
    activity: "yelling"
  },
  {
    name: "Oink",
    alias: "Rick",
    color: "grayish",
    food: "rib bones",
    activity: "yelling"
  },
  {
    name: "Ricky 1",
    color: "black",
    food: "meh",
    activity: "bullying max"
  }
]
h
exit
load 'lib/dm_engine/treatment/treatments/glucose.rb'
$
$_
_$
$:
.pwd
.ls
exit
load 'lib/dm_engine/values/drug_opt_list_group.rb'
load 'lib/dm_engine/values/drug_opt_list.rb'
include DmEngine
DrugOptListGroup.new
DrugOptList.new
exit
.pry -v
exit
? Enumerable#each
ls Enumerable
ls Array
ls Set
? Enumerable#map
$ Enumerable#map
$ Array#each
$ Set#each
$ Hash#each
load 'lib/dm_engine/values/drug_opt_list.rb'
include DmEngine
d = DrugOptList.new ["d1", "d2", "d3"]
exit
load 'lib/dm_engine/values/drug_opt_list.rb'
d = DrugOptList.new ["d1", "d2", "d3"]
include DmEngine
d = DrugOptList.new ["d1", "d2", "d3"]
.gem list
require "pp"
pp d
p d
ls Kernel
ls BasicObject
? Kernel.pp
ppd
pp d
d.each do |e| pp e end
d.each do |e| p e end
d.each do |e| puts e end
load 'lib/dm_engine/values/drug_opt_list_group.rb'
e = DrugOptList.new ["d1", "d2", "d3"]
g = DrugOptListGroup.new [d, e]
g.each do |e| puts e end
g.any? { |e| e == "d1" }
g.any? { |e| e == "d5" }
d.any? { |e| e == "d1" }
load 'lib/dm_engine/values/drug_opt_list.rb'
d.each do |e| pp e end
reload DrugOptList#each
reload-method DrugOptList#each
d.each do |e| pp e end
load 'lib/dm_engine/values/drug_opt_list.rb'
load 'lib/dm_engine/values/drug_opt_list_group.rb'
reload-method DrugOptList#each
reload-method DrugOptListGroup#each
d = DrugOptList.new ["c1", "c2", "c3"]
d.each do |e| pp e end
d.each do |e| pp e end.class
g.each do |e| pp e end
g.each do |e| pp e end.class
load 'lib/dm_engine/values/drug_opt_list.rb'
load 'lib/dm_engine/values/drug_opt_list_group.rb'
d.each do |e| pp e end
g.each do |e| pp e end
g.each do |e| pp e end.map { |e| e.upcase }
g.select { |e| e ~= "1" }
g.select { |e| e =~ "1" }
? String#=~
? Object#=~
"d1" =~ "1"
"d1" =~ /1/
"d1".match "1"
"d1" =~ /9/
g.select { |e| e ~= /1/ }
g.select { |e| e =~ /1/ }
g
g.map { |e| e.upcase }
load 'lib/dm_engine/values/drug_opt_list_group.rb'
g.map { |e| e.upcase }
load 'lib/dm_engine/values/drug_opt_list_group.rb'
g.map { |e| e.upcase }
load 'lib/dm_engine/values/drug_opt_list_group.rb'
g.map { |e| e.upcase }
oad 'lib/dm_engine/values/drug_opt_list_group.rb'
load 'lib/dm_engine/values/drug_opt_list_group.rb'
g.map { |e| e.upcase }
load 'lib/dm_engine/values/drug_opt_list_group.rb'
g.map { |e| e.upcase }
load 'lib/dm_engine/values/drug_opt_list.rb'
g.map { |e| e.upcase }
d.map { |e| e.upcase }
load 'lib/dm_engine/values/drug_opt_list.rb'
load 'lib/dm_engine/values/drug_opt_list_group.rb'
d.map { |e| e.upcase }
g.map { |e| e.upcase }
load 'lib/dm_engine/values/drug_opt_list.rb'
load 'lib/dm_engine/values/drug_opt_list_group.rb'
d.map { |e| e.upcase }
g.map { |e| e.upcase }
$ Enumerable#map
$ Enumerable#collect
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drug_list.rb'
include DmEngine
dl = DrugList.new ["a", "b", "c"]
dl.map(&:upcase)
dl
[1, 2, 3].map
[1, 2, 3].map.select.to_a
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drug_list.rb'
dl.map
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drug_list.rb'
dl.map
dl.map(&:upcase)
dl.map { |d| d.succ }
dl
first, *rest = *Set[1, 2, 3]
first
rest
[1, 2, 3].rest
[1, 2, 3].first
Set[1, 2, 3][1..-1]
[1, 2, 3][1..-1]
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drug_list.rb'
s1 = Set[]
def rec_map fn, col
  first, *rest = *col
  if col.empty?
    Set[]
  elsif !first.is_a?(Enumerable)
    Set[fn.call(first)] + rec_map(fn, rest)
  else
    rec_map(fn, first) + rec_map(fn, rest)
  end
end
rec_map lambda { |i| i + 1 }, s1
s2 = Set[1]
rec_map lambda { |i| i + 1 }, s2
s3 = Set[1, 2, 3]
rec_map lambda { |i| i + 1 }, s3
s4 = Set[Set[]]
rec_map lambda { |i| i + 1 }, s4
s4
s5 = Set[Set[1, 2, 3], Set[5, 6, 7]]
rec_map lambda { |i| i + 1 }, s5
def rec_map fn, col
  first, *rest = *col
  if col.empty?
    Set[]
  elsif !first.is_a?(Enumerable)
    Set[fn.call(first)] + rec_map(fn, rest)
  else
    Set.new(rec_map(fn, first), Set.new(*rec_map(fn, rest)))
  end
end
rec_map lambda { |i| i + 1 }, s1
rec_map lambda { |i| i + 1 }, s2
rec_map lambda { |i| i + 1 }, s3
rec_map lambda { |i| i + 1 }, s4
def rec_map fn, col
  first, *rest = *col
  if col.empty?
    Set[]
  elsif !first.is_a?(Enumerable)
    Set[fn.call(first)] + rec_map(fn, rest)
  else
    Set.new(rec_map(fn, first), rec_map(fn, rest))
  end
end
esses = [s1, s2, s3, s4, s5]
def test_rec_map
def test_rec_map &block
def test_rec_map
  esses.map { |s| rec_map lambda { |i| i + 1 }, s }
end
test_rec_map
esses
def test_rm &fn, col
def test_rm fn, col
  col.map { |c| rec_map fn, c }
end
test_rm lambda { |i| i + 1 }, esses
rec_map lambda { |i| i + 1 }, s1
rec_map lambda { |i| i + 1 }, s2
rec_map lambda { |i| i + 1 }, s3
rec_map lambda { |i| i + 1 }, s4
s4
def rec_map fn, col
  first, *rest = *col
  if col.empty?
    Set[]
  elsif !first.is_a?(Enumerable)
    Set[fn.call(first)] + rec_map(fn, rest)
  else
    Set[rec_map(fn, first), *rec_map(fn, rest)]
  end
end
rec_map lambda { |i| i + 1 }, s1
rec_map lambda { |i| i + 1 }, s2
rec_map lambda { |i| i + 1 }, s3
rec_map lambda { |i| i + 1 }, s4
rec_map lambda { |i| i + 1 }, s5
s5
s6 = Set[Set[Set[1, 2, 3], Set[5, 6, 7]], 11, 12, 13], 15, 16, 17]
s6 = Set[
  Set[
    Set[1, 2, 3],
    Set[5, 6, 7],
    9
  ],
  11,
  12,
  Set[
    Set[
      Set[
        15,
        16,
        17
      ]
    ],
    18
  ]
]
rec_map lambda { |i| i + 1 }, s6
def rec_map fn, col
  first, *rest = *col
  if col.empty?
    []
  elsif !first.is_a?(Enumerable)
    [fn.call(first)] + rec_map(fn, rest)
  else
    [rec_map(fn, first), *rec_map(fn, rest)]
  end
end
rec_map lambda { |i| i + 1 }, s6
pp rec_map lambda { |i| i + 1 }, s6
require "util"
Util.as_nested_sets(rec_map( lambda { |i| i + 1 }, s6))
esses
esses << s6
test_rm lambda { |i| i + 1 }, esses
def rec_map fn, col
  col.map { |e|
    if e.is_a?(Enumerable)
      rec_map fn, e
    else
      fn.call e
    end
  }
end
$ test_rm
def test_rm fn, col
  col.map { |c| rec_map fn, c }
end
test_rm lambda { |i| i + 1 }, esses
$ rec_map
Util.as_nested_sets(rec_map(lambda { |i| i*i }, s1))
Util.as_nested_sets(rec_map(lambda { |i| i*i }, s2))
Util.as_nested_sets(rec_map(lambda { |i| i*i }, s3))
Util.as_nested_sets(rec_map(lambda { |i| i*i }, s4))
Util.as_nested_sets(rec_map(lambda { |i| i*i }, s5))
Util.as_nested_sets(rec_map(lambda { |i| i*i }, s6))
def rec_select pred, col
  col.select { |e|
    if e.is_a?(Enumerable)
      rec_select pred, col
    else
      pred.call e
    end
  }
end
def test_rec_fn rec_fn, fn, col
  col.map { |c| rec_fn, fn, c }
def test_rec_fn rec_fn, fn, col
  col.map { |c| rec_fn.call fn, c }
end
test_rec_fn rec_map, lambda { |i| i*i }, esses
rec_map.to_proc
:rec_map.to_proc
:rec_map.to_proc.call lambda { |i| i*i }, esses
send :rec_map, lambda { |i| i*i }, esses
def test_rec_fn rec_fn, fn, col
  col.map { |c| send rec_fn, fn, c }
end
test_rec_fn :rec_map, lambda { |i| i*i }, esses
test_rec_fn :rec_select, lambda { |i| i.odd? }, esses
rec_select lambda { |i| i.odd? }, s1
rec_select lambda { |i| i.odd? }, s2
rec_select lambda { |i| i.odd? }, s3
rec_select lambda { |i| i.odd? }, s4
rec_select lambda { |i| i.odd? }, s5
rec_select lambda { |i| i.odd? }, s6
edit rec_select
rec_select lambda { |i| i.odd? }, s6
rec_select lambda { |i| i.odd? }, s4
rec_select lambda { |i| i.odd? }, s5
edit rec_select
rec_select lambda { |i| i.odd? }, s5
e
step
e.is_a?(Enumerable)
step
e
step
next
finish
!!!
e
e.is_a?(Enumerable)
pred.call e
step
def rec_any_component_empty? col
  first, *rest = *col
  if col.empty?
    true
  elsif !first.respond_to?(:empty?)
    if rest.empty?
      false
    else
      rec_any_component_empty? rest
    end
  else
    rec_any_component_empty?(first) || rec_any_component_empty?(rest)
  end
end
hist
hist --replay 4312..4473
s1
s6
def rec_any_component_empty? col
  first, *rest = *col
  if col.empty?
    true
  elsif !first.respond_to?(:empty?)
    if rest.empty?
      false
    else
      rec_any_component_empty? rest
    end
  else
    rec_any_component_empty?(first) || rec_any_component_empty?(rest)
  end
end
rec_any_component_empty? s1
rec_any_component_empty? s2
rec_any_component_empty? s3
rec_any_component_empty? s4
rec_any_component_empty? s5
rec_any_component_empty? s6
rec_any_component_empty? [1, [2, 3], [4, [5, [], 6]]]
def rec_any_component_empty? col
  first, *rest = *col
  if col.empty?
    true
  elsif first.repond_to?(:empty?)
    rec_any_component_empty?(first) || rec_any_component_empty?(rest)
  elsif rest.empty?
    false
  else
    rec_any_component_empty? rest
  end
end
rec_any_component_empty? s1
rec_any_component_empty? s2
def rec_any_component_empty? col
  first, *rest = *col
  if col.empty?
    true
  elsif first.respond_to?(:empty?)
    rec_any_component_empty?(first) || rec_any_component_empty?(rest)
  elsif rest.empty?
    false
  else
    rec_any_component_empty? rest
  end
end
rec_any_component_empty? s1
rec_any_component_empty? s2
rec_any_component_empty? s3
rec_any_component_empty? s4
rec_any_component_empty? s5
rec_any_component_empty? s6
rec_any_component_empty? [1, [2, 3], [4, [5, [], 6]]]
s5
s6
def rec_any_component_empty? col
  first, *rest = *col
  binding.pry
  if col.empty?
    true
  elsif !first.respond_to?(:empty?)
    if rest.empty?
      false
    else
      rec_any_component_empty? rest
    end
  else
    rec_any_component_empty?(first) || rec_any_component_empty?(rest)
  end
end
rec_any_component_empty? s5
col
next
col
next
first
next
col
next
back
prev
up
!!!
next
col
next
first
next
rest
next
help
whereami
next
finish
!!!
next
col
next
rest
next
finish
!!!
col
next
first
next
rest
next
col
next
first
rest
!!!
hist --replay 4312..4473
def rec_any_component_empty? col
  first, *rest = *col
  binding.pry
  if col.empty?
    true
  elsif !first.respond_to?(:empty?)
    if rest.empty?
      false
    else
      rec_any_component_empty? rest
    end
  else
    rec_any_component_empty?(first) || rec_any_component_empty?(rest)
  end
end
def rec_any_component_empty? col
  first, *rest = *col
  binding.pry
  if col.empty?
    true
  elsif !first.respond_to?(:empty?)
    if rest.empty?
      false
    else
      rec_any_component_empty? rest
    end
  else
    rec_any_component_empty?(first) || rec_any_component_empty?(rest)
  end
end
rec_any_component_empty? s6
col
finish
!!!
hist --replay 4312..4473
def rec_any_component_empty? col
  first, *rest = *col
  binding.pry
  if col.empty?
    true
  elsif !first.respond_to?(:empty?)
    if rest.empty?
      false
    else
      rec_any_component_empty? rest
    end
  else
    rec_any_component_empty?(first) || rec_any_component_empty?(rest)
  end
end
s5
rec_any_component_empty? s5
first
rest
f, *r = *rest
f
r
finish
continue
!!!
drug_list
!drug_list.includes_component?(attr: :drug_type, value: "insulin")
drug_list.includes_component?(attr: :drug_type, value: "insulin")
drug_list.any_component_empty?
!!!
f, *r = [1, 2, 3]
f
r
fs, *rs = *[1, 2, 3]
fs
rs
m = [
load 'lib/dm_engine/values/drug_list.rb'
load 'lib/dm_engine/values/drug_list_group_list.rb'
load '/home/cort/Projects/dm_app/dm_engine/lib/dm_engine/values/drug_list_group.rb'
include DmEngine
mets = [
  DrugListGroupList.new([
      DrugListGroup.new([
          DrugList.new([
              "metformin er 1", metformin er 2"
amend-line
amend-line 12
mets = [
  DrugListGroupList.new([
      DrugListGroup.new([
          DrugList.new([
              "met 1", "met 2"
          ])
      ])
  ])
]
basals = [
  DrugListGroupList.new([
      DrugListGroup.new([
          DrugList.new([
              "basal 1", "basal 2"
          ])
      ])
  ])
]
mets = [
  DrugListGroup.new([
      DrugList.new([
          "met 1", "met 2"
      ])
  ])
]
basals = [
  DrugListGroup.new([
      DrugList.new([
          "basal 1", "basal 2"
      ])
  ])
]
groups = [mets, basals]
f, *r = *groups
f
r
f.product(*r)
f.product(*r).map { |e| DrugListGroupList.new e }
load 'lib/dm_engine/values/drug_list.rb'
load 'lib/dm_engine/values/drug_list_group_list.rb'
load 'lib/dm_engine/values/drug_list_group.rb'
d
ls mets
dlgl = DrugListGroupList.new(Set[
    DrugListGroup.new(Set[
        DrugList.new(Set[
            Point.new(1, 1), Point.new(2, 2)
        ])
    ])
])
Point = Struct.new :x, :y
dlgl = DrugListGroupList.new(Set[
    DrugListGroup.new(Set[
        DrugList.new(Set[
            Point.new(1, 1), Point.new(2, 2)
        ])
    ])
])
dlgl2 = DrugListGroupList.new(Set[
    DrugListGroup.new(Set[
        DrugList.new(Set[
            Point.new(-1, -1), Point.new(0, 0)
        ])
    ])
])
dlgl.includes_component? attr: :x, value: 1
dlgl3 = DrugListGroupList.new(Set[
    DrugListGroup.new(Set[
        DrugList.new(Set[
            Point.new(1, 1), Point(1, 0)
        ])
    ])
])
dlgl3 = DrugListGroupList.new(Set[
    DrugListGroup.new(Set[
        DrugList.new(Set[
            Point.new(1, 1), Point.new(1, 0)
        ])
    ])
])
dlgl4 = DrugListGroupList.new(Set[
    DrugListGroup.new(Set[
        DrugList.new(Set[
        ])
    ])
])
dlgl2.includes_component? attr: :x, value: 1
dlgl3.includes_component? attr: :x, value: 1
dlgl4.includes_component? attr: :x, value: 1
load 'lib/dm_engine/values/drug_list_group_list.rb'
load 'lib/dm_engine/values/drug_list_group.rb'
dlgl1.includes_component? attr: :x, value: 1
dlgl.includes_component? attr: :x, value: 1
dlgl.includes_component? { |drug| drug.x > 0 }
load 'lib/dm_engine/values/drug_list_group.rb'
dlgl.includes_component? { |drug| drug.x > 0 }
dlgl
dlgl.includes_component? { |drug| drug.x > 0 && drug.y > 0 }
dlgl.includes_component? { |drug| drug.x == 1 }
dlgl2.includes_component? { |drug| drug.x == 1 }
dlgl2.includes_component? { |drug| drug.x > = }
dlgl2.includes_component? { |drug| drug.x > 0 }
dlgl2
ls 1
ls Math
dlgl2.includes_component? { |drug| drug.x.abs > 0 }
dlgl2.includes_component? { |drug| drug.x.abs < 2 }
load 'lib/dm_engine/values/drug_list_group_list.rb'
load 'lib/dm_engine/values/drug_list_group.rb'
dlgl4.select_component { |c| !c.empty? }
dlgl4
dlgl4.select_component { |c| c.empty? }
.pry -v
require "set"
j = *Set[]
j
j = [*[]]
j
Set["d", "o", "g"].join(", ")
Set["d", "o", "g"].to_a.join(", ")
Set["d", "o", "g"].to_a.join("")
load 'lib/dm_engine/values/drug_list_group.rb'
Drug = Struct.new :name, :drug_class
met1 = Drug.new "Met 1", "metformin"
met2 = Drug.new "Met 2", "metformin"
su1 = Drug.new "SU 1", "sulfonylurea"
su2 = Drug.new "SU 2", "sulfonylurea"
load 'lib/dm_engine/values/drug_list.rb'
dlg1 = DrugListGroup.new(Set[
    DrugList.new(Set[
        met1, met2
    ])
])
include DmEngine
dlg1 = DrugListGroup.new(Set[
    DrugList.new(Set[
        met1, met2
    ])
])
dlg1.drug_class
load 'lib/dm_engine/values/drug_list_group.rb'
dlg1.drug_class
dlg1 = DrugListGroup.new(Set[
    DrugList.new(Set[
        su1, su2
    ])
])
dlg1.drug_class
dlg3 = DrugListGroup.new(Set[
    DrugList.new(Set[
        met1, met2
    ])
dlg3 = DrugListGroup.new(Set[
    DrugList.new(Set[
        met1, met2
    ]),
    DrugList.new(Set[
        su1, su2
    ])
])
dlg3.drug_class
load 'lib/dm_engine/values/drug_list_group.rb'
dlg3.drug_class
load 'lib/dm_engine/values/drug_list_group_list.rb'
load 'lib/dm_engine/values/drug_list_group.rb'
load 'lib/dm_engine/values/drug_list.rb'
include DmEngine
dl = DrugList.new Set["a", "b", "c"]
dlg = DrugListGroup.new Set[dl]
dlgl = DrugListGroupList.new Set[dlg]
dl.to_a
dlg.to_a
dlgl.to_a
load 'lib/dm_engine/values/drug_rationale.rb'
dr = DrugRationale.new drug: dlg, rationale: "rationale"
dlgl2 = DrugListGroupList.new Set[dr]
dlgl2.to_a
load 'lib/dm_engine/values/drug_rationale.rb'
dlgl2.to_a
dlgl1.to_a
dlgl.to_a
dlgl2
dlgl
dr
dr.to_a
reload DrugRationale#to_a
reload-method DrugRationale#to_a
dr.to_a
load 'lib/dm_engine/values/drug_rationale.rb'
dr.to_a
dr
dr.drug
dr.drug.to_a
load 'lib/dm_engine/values/drug_rationale.rb'
$ DrugRationale#to_a
reload-method dr.to_a
reload-method dr#to_a
reload-method DrugRationale#to_a
$ dr.to_a
dr2 = DrugRationale drug: Set["b"], rationale: "rat"
dr2 = DrugRationale.new drug: Set["b"], rationale: "rat"
dr2
dr2.to_a
dr.to_a
dr = DrugRationale.new drug: dlg, rationale: "rationale"
dr.to_a
dlgl2 = DrugListGroupList.new Set[dr]
dlgl2.to_a
require "diffy"
exit
require "diffy"
Diffy
exit
gem-cd diffy
gem-cd minitest
up
back
cd ..
cd ./..
back
up
!!!
exit
require "diffy"
gem-cd diffy
gem-cd yard
gem-cd awesome_print
ls
gem-cd diffy
cd ..
ls
Diffy
include Diffy
help
gem-open diffy
gem-open minitest
exit
gem-open minitest
help
gem-open minitest
gem-list
gem-open minitest-5.3.5
gem-open minitest_5.3.5
gem-open minitest5.3.5
gem-open minitest(5.3.5)
gem-open minitest 5.3.5
exit
gem-list
.gem list
exit
gem-list
exit
require "bigdecimal"
require "rake"
require "test_unit"
require "testunit"
require "test-unit"
require "test/unit"
exit
gem-list
require "diffy"
exit
require "diffy"
gem-list
exit
gem-list
require "diffy"
exit
gem-list
require "diffy"
expected = [{:treatment_type=>"glucose", :instructions=>["Return in 1 - 2 weeks to adjust treatment based on glucose records."], :partial_plans=>{"start drugs objective"=>{:rationale=>"start drugs rationale", :drug_change_type=>"start", :drugs=>[{:drug=>[[{:name=>"Glargine", :dosing_route=>"SC", :dosings=>[{:time=>"am", :dose=>{:amount=>[10, 20], :unit=>"units"}}]}, {:name=>"Detemir", :dosing_route=>"SC", :dosings=>[{:time=>"pm", :dose=>{:amount=>[10, 20], :unit=>"units"}}]}]], :rationale=>"Rationale for starting basal insulin."}]}, "stop drugs objective"=>{:rationale=>"stop drugs rationale", :drug_change_type=>"stop", :drugs=>[{:drug=>{:name=>"Saxagliptin", :dosing_route=>"PO", :dosings=>[{:time=>"d", :dose=>{:atom_denomination=>(5/2), :number_of_atoms=>1, :unit=>"mg"}}]}, :rationale=>"Rationale for stoping Saxagliptin."}]}, "change drugs objective"=>{:rationale=>"change drugs rationale", :drug_change_type=>"change", :drugs=>[{:drug=>{:name=>"Liraglutide", :dosing_route=>"SC", :dosings=>[{:time=>"am", :dose=>{:atom_denomination=>(3/5), :number_of_atoms=>1, :unit=>"mg"}}]}, :rationale=>"Rationale for changing Liraglutide."}]}, "continue drugs objective"=>{:rationale=>"continue drugs rationale", :drug_change_type=>"continue", :drugs=>[{:drug=>{:name=>"Metformin ER", :dosing_route=>"PO", :dosings=>[{:time=>"pm", :dose=>{:atom_denomination=>500, :number_of_atoms=>2, :unit=>"mg"}}]}, :rationale=>"Rationale for continuing Metformin ER."}]}}}]
actual = [{:treatment_type=>"glucose", :instructions=>["Return in 1 - 2 weeks to adjust treatment based on glucose records."], :partial_plans=>{"start drugs objective"=>{:rationale=>"start drugs rationale", :drug_change_type=>"start", :drugs=>[{:drug=>[[{:name=>"Glargine", :dosing_route=>"SC", :dosings=>[{:time=>"am", :dose=>{:amount=>[10, 20], :unit=>"units"}}]}, {:name=>"Detemir", :dosing_route=>"SC", :dosings=>[{:time=>"pm", :dose=>{:amount=>[10, 20], :unit=>"units"}}]}]], :rationale=>"Rationale for starting basal insulin."}]}, "stop drugs objective"=>{:rationale=>"stop drugs rationale", :drug_change_type=>"stop", :drugs=>[{:drug=>{:name=>"Saxagliptin", :dosing_route=>"PO", :dosings=>[{:time=>"d", :dose=>{:atom_denomination=>(5/2), :number_of_atoms=>1, :unit=>"mg"}}]}, :rationale=>"Rationale for stopping Saxagliptin."}]}, "change drugs objective"=>{:rationale=>"change drugs rationale", :drug_change_type=>"change", :drugs=>[{:drug=>{:name=>"Liraglutide", :dosing_route=>"SC", :dosings=>[{:time=>"am", :dose=>{:atom_denomination=>(3/5), :number_of_atoms=>1, :unit=>"mg"}}]}, :rationale=>"Rationale for changing Liraglutide."}]}, "continue drugs objective"=>{:rationale=>"continue drugs rationale", :drug_change_type=>"continue", :drugs=>[{:drug=>{:name=>"Metformin ER", :dosing_route=>"PO", :dosings=>[{:time=>"pm", :dose=>{:atom_denomination=>500, :number_of_atoms=>2, :unit=>"mg"}}]}, :rationale=>"Rationale for continuing Metformin ER."}]}}}]
Diffy::Diff.new(expected, actual)
puts Diffy::Diff.new(expected, actual)
expected = "[{:treatment_type=>\"glucose\", :instructions=>[\"Return in 1 - 2 weeks to adjust treatment based on glucose records.\"], :partial_plans=>{\"start drugs objective\"=>{:rationale=>\"start drugs rationale\", :drug_change_type=>\"start\", :drugs=>[{:drug=>[[{:name=>\"Glargine\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"am\", :dose=>{:amount=>[10, 20], :unit=>\"units\"}}]}, {:name=>\"Detemir\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"pm\", :dose=>{:amount=>[10, 20], :unit=>\"units\"}}]}]], :rationale=>\"Rationale for starting basal insulin.\"}]}, \"stop drugs objective\"=>{:rationale=>\"stop drugs rationale\", :drug_change_type=>\"stop\", :drugs=>[{:drug=>{:name=>\"Saxagliptin\", :dosing_route=>\"PO\", :dosings=>[{:time=>\"d\", :dose=>{:atom_denomination=>(5/2), :number_of_atoms=>1, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for stoping Saxagliptin.\"}]}, \"change drugs objective\"=>{:rationale=>\"change drugs rationale\", :drug_change_type=>\"change\", :drugs=>[{:drug=>{:name=>\"Liraglutide\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"am\", :dose=>{:atom_denomination=>(3/5), :number_of_atoms=>1, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for changing Liraglutide.\"}]}, \"continue drugs objective\"=>{:rationale=>\"continue drugs rationale\", :drug_change_type=>\"continue\", :drugs=>[{:drug=>{:name=>\"Metformin ER\", :dosing_route=>\"PO\", :dosings=>[{:time=>\"pm\", :dose=>{:atom_denomination=>500, :number_of_atoms=>2, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for continuing Metformin ER.\"}]}}}]"
actual = "[{:treatment_type=>\"glucose\", :instructions=>[\"Return in 1 - 2 weeks to adjust treatment based on glucose records.\"], :partial_plans=>{\"start drugs objective\"=>{:rationale=>\"start drugs rationale\", :drug_change_type=>\"start\", :drugs=>[{:drug=>[[{:name=>\"Glargine\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"am\", :dose=>{:amount=>[10, 20], :unit=>\"units\"}}]}, {:name=>\"Detemir\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"pm\", :dose=>{:amount=>[10, 20], :unit=>\"units\"}}]}]], :rationale=>\"Rationale for starting basal insulin.\"}]}, \"stop drugs objective\"=>{:rationale=>\"stop drugs rationale\", :drug_change_type=>\"stop\", :drugs=>[{:drug=>{:name=>\"Saxagliptin\", :dosing_route=>\"PO\", :dosings=>[{:time=>\"d\", :dose=>{:atom_denomination=>(5/2), :number_of_atoms=>1, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for stopping Saxagliptin.\"}]}, \"change drugs objective\"=>{:rationale=>\"change drugs rationale\", :drug_change_type=>\"change\", :drugs=>[{:drug=>{:name=>\"Liraglutide\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"am\", :dose=>{:atom_denomination=>(3/5), :number_of_atoms=>1, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for changing Liraglutide.\"}]}, \"continue drugs objective\"=>{:rationale=>\"continue drugs rationale\", :drug_change_type=>\"continue\", :drugs=>[{:drug=>{:name=>\"Metformin ER\", :dosing_route=>\"PO\", :dosings=>[{:time=>\"pm\", :dose=>{:atom_denomination=>500, :number_of_atoms=>2, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for continuing Metformin ER.\"}]}}}]"
puts Diffy::Diff.new(expected, actual)
exit
require "differ"
expected = "[{:treatment_type=>\"glucose\", :instructions=>[\"Return in 1 - 2 weeks to adjust treatment based on glucose records.\"], :partial_plans=>{\"start drugs objective\"=>{:rationale=>\"start drugs rationale\", :drug_change_type=>\"start\", :drugs=>[{:drug=>[[{:name=>\"Glargine\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"am\", :dose=>{:amount=>[10, 20], :unit=>\"units\"}}]}, {:name=>\"Detemir\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"pm\", :dose=>{:amount=>[10, 20], :unit=>\"units\"}}]}]], :rationale=>\"Rationale for starting basal insulin.\"}]}, \"stop drugs objective\"=>{:rationale=>\"stop drugs rationale\", :drug_change_type=>\"stop\", :drugs=>[{:drug=>{:name=>\"Saxagliptin\", :dosing_route=>\"PO\", :dosings=>[{:time=>\"d\", :dose=>{:atom_denomination=>(5/2), :number_of_atoms=>1, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for stoping Saxagliptin.\"}]}, \"change drugs objective\"=>{:rationale=>\"change drugs rationale\", :drug_change_type=>\"change\", :drugs=>[{:drug=>{:name=>\"Liraglutide\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"am\", :dose=>{:atom_denomination=>(3/5), :number_of_atoms=>1, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for changing Liraglutide.\"}]}, \"continue drugs objective\"=>{:rationale=>\"continue drugs rationale\", :drug_change_type=>\"continue\", :drugs=>[{:drug=>{:name=>\"Metformin ER\", :dosing_route=>\"PO\", :dosings=>[{:time=>\"pm\", :dose=>{:atom_denomination=>500, :number_of_atoms=>2, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for continuing Metformin ER.\"}]}}}]"
actual = "[{:treatment_type=>\"glucose\", :instructions=>[\"Return in 1 - 2 weeks to adjust treatment based on glucose records.\"], :partial_plans=>{\"start drugs objective\"=>{:rationale=>\"start drugs rationale\", :drug_change_type=>\"start\", :drugs=>[{:drug=>[[{:name=>\"Glargine\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"am\", :dose=>{:amount=>[10, 20], :unit=>\"units\"}}]}, {:name=>\"Detemir\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"pm\", :dose=>{:amount=>[10, 20], :unit=>\"units\"}}]}]], :rationale=>\"Rationale for starting basal insulin.\"}]}, \"stop drugs objective\"=>{:rationale=>\"stop drugs rationale\", :drug_change_type=>\"stop\", :drugs=>[{:drug=>{:name=>\"Saxagliptin\", :dosing_route=>\"PO\", :dosings=>[{:time=>\"d\", :dose=>{:atom_denomination=>(5/2), :number_of_atoms=>1, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for stopping Saxagliptin.\"}]}, \"change drugs objective\"=>{:rationale=>\"change drugs rationale\", :drug_change_type=>\"change\", :drugs=>[{:drug=>{:name=>\"Liraglutide\", :dosing_route=>\"SC\", :dosings=>[{:time=>\"am\", :dose=>{:atom_denomination=>(3/5), :number_of_atoms=>1, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for changing Liraglutide.\"}]}, \"continue drugs objective\"=>{:rationale=>\"continue drugs rationale\", :drug_change_type=>\"continue\", :drugs=>[{:drug=>{:name=>\"Metformin ER\", :dosing_route=>\"PO\", :dosings=>[{:time=>\"pm\", :dose=>{:atom_denomination=>500, :number_of_atoms=>2, :unit=>\"mg\"}}]}, :rationale=>\"Rationale for continuing Metformin ER.\"}]}}}]"
Differ.diff_by_word(expected, actual)
load 'lib/dm_engine/values/drug_list.rb'
load 'lib/dm_engine/values/drug_list_group.rb'
load 'lib/dm_engine/values/drug_list_group_list.rb'
d
dl = DrugList.new Set["a", "b", "c"]
include DmEngine
dl = DrugList.new Set["a", "b", "c"]
dl1 = DrugList.new Set["a", "b", "c"]
dl2 = DrugList.new Set["d", "e", "f"]
dlg1 = DrugListGroup.new Set[dl1, dl2]
dlg2 = DrugListGroup.new Set[dl1, dl2]
dlgl1 = DrugListGroupList.new Set[dlg1, dlg2]
dlgl1.partition { |e| e < "e" }
dl1.partition { |e| e < "e" }
dlg1.partition { |e| e < "e" }
load 'lib/dm_engine/values/drug_list_group.rb'
dlg1.partition { |e| e < "e" }
load 'lib/dm_engine/values/drug_list_group_list.rb'
dlgl1.partition { |e| e < "e" }
load 'lib/dm_engine/values/drug_list_group.rb'
dlg1.partition { |e| e < "e" }
load 'lib/dm_engine/values/drug_list_group.rb'
dlg1.partition { |e| e < "e" }
load 'lib/dm_engine/values/drug_list_group_list.rb'
dlgl1.partition { |e| e < "e" }
load 'lib/dm_engine/values/drug_list_group.rb'
load 'lib/dm_engine/values/drug_list_group_list.rb'
dlg1.include { |e| e == "a" }
dlg1.include "a"
dlg1.include? "a"
dlg1.include? "b"
dlg1.include? "f"
dlg1.include? "fg
dlg1.include? "g"
dlgl1.include? "a"
dlgl1.include? "f"
dlgl1.include? "g"
dlgl1
dl
dlg2
dlgl2 = DrugListGroupList.new Set[dlg2]
dlgl1
dlgl1 - dlgl2
dlg3 = DrugListGroup.new Set[dl2]
dlgl3 = DrugListGroupList.new Set[dlg3]
dlgl2 - dlgl3
[Set["a"], Set["b"], Set["c]].flatten
[Set["a"], Set["b"], Set["c"]].flatten
$ Array#flatten
Set[Set["a"], Set["b"], Set["c"]].flatten
def my_flatten *cols
  return cols if cols.empty?
  cols.reduce :+
end
my_flatten Set[Set["a"], Set["b"], Set["c"]]
Set[Set["a"], Set["b"], Set["c"]].empty?
edit my_flatten
my_flatten Set[Set["a"], Set["b"], Set["c"]]
cols
exit
edit my_flatten
my_flatten Set[Set["a"], Set["b"], Set["c"]]
exit
h = {
  :multiple => ([1, 2].length > 1),
}
"\s"
'\s'
exit
pry-version
:dog?.class
(60...80).include? 80
(60..80).include? 80
a = -> { p "haha" }
a
a.call
b = lambda { p "heehee" }
b
b.call
Animal = Struct.new :name, :color, :size
Animal = Struct.new :type, :color, :name
spook = Animal.new "dog", "gray", "Spook"
spook.map { |e| p e }
spook.members.map { |k| p "#{k}: #{spook[k]}" }
spook.to_h
$ String#gsub
? String#gsub
"dog face".capitalize
"dog face".titlecase
"glucose[fasting][mode-region][rat]".match(/[\w\-]*/)
? String#match
"glucose[fasting][mode-region][rat]".match(/[\w\-]*/).last
"glucose[fasting][mode-region][rat]".match(/[\w\-]*/)[-1]
"glucose[fasting][mode-region][rat]".match(/[\w\-]*/).to_a
"glucose[fasting][mode-region][rat]".match(/[\w\-]*/) { |e| p e }
"glucose[fasting][mode-region][rat]".match(/[\w\-]*/g)
"glucose[fasting][mode-region][rat]".split(/[\]\[]/)
"glucose[fasting][mode-region][rat]".split(/[\]\[]/).compact
"glucose[fasting][mode-region][rat]".split(/[\]\[]/).reject(&:empty)
"i".empty?
"glucose[fasting][mode-region][rat]".split(/[\]\[]/).reject(&:empty?)
def as_bool value
  [1, "yes"].include(value) ? true : false
end
as_bool(1)
ls Array
def as_bool value
  [1, "yes"].include?(value) ? true : false
end
ls Array
as_bool(1)
as_bool("yes")
as_bool("ye")
as_bool("no")
as_bool("0")
as_bool("1")
as_bool(0)
as_bool(-1)
as_bool(1)
{"utf8"=>"✓", "authenticity_token"=>"VroP3FHDNyxBNNbttFyC05UBt7GRjIxf7R3bd6YoUhY=", "goal-a1c"=>"7", "a1c"=>"7.9", "creatinine"=>"1", "gender"=>"female", "gfr"=>"100", "height-in-in"=>"78", "weight-in-lb"=>"221", "glucose_rec
ord"=>{"fasting"=>{"very-low-values"=>"yes", "mode-region"=>"Not identifiable", "low-values"=>"yes", "very-high-values"=>"yes", "values-distributed-over-gte-four-regions"=>"yes", "values-mostly-in-regions-separated-by-two-regions"=>"yes", 
      "mostly-low-and-marginally-elevated-values"=>"yes", "mostly-low-and-marginally-elevated-values-explanation"=>"Low", "mostly-high-and-very-high-values"=>"yes", "at-least-twenty-percent-of-values-at-goal"=>"yes", "number-very-high-values-gte
-twice-number-at-goal"=>"yes", "values-distributed-between-at-goal-and-marginally-elevated-and-high"=>"yes", "gte-about-half-of-values-at-goal"=>"yes", "almost-all-values-not-at-goal-are-high"=>"yes", "values-distributed-between-at-goal-an
d-high-and-very-high"=>"yes", "very-few-marginally-elevated-values"=>"yes", "explanation-for-high-and-very-high-values"=>"yes"}, "noon-meal"=>{"very-low-values"=>"yes", "mode-region"=>"Not identifiable", "low-values"=>"yes", "very-high-val
ues"=>"yes", "values-distributed-over-gte-four-regions"=>"yes", "values-mostly-in-regions-separated-by-two-regions"=>"yes", "mostly-low-and-marginally-elevated-values"=>"yes", "mostly-low-and-marginally-elevated-values-explanation"=>"Low",
      "mostly-high-and-very-high-values"=>"yes", "at-least-twenty-percent-of-values-at-goal"=>"yes", "number-very-high-values-gte-twice-number-at-goal"=>"yes", "values-distributed-between-at-goal-and-marginally-elevated-and-high"=>"yes", "gte-a
bout-half-of-values-at-goal"=>"yes", "almost-all-values-not-at-goal-are-high"=>"yes", "values-distributed-between-at-goal-and-high-and-very-high"=>"yes", "very-few-marginally-elevated-values"=>"yes", "explanation-for-high-and-very-high-val
ues"=>"yes"}, "evening-meal"=>{"very-low-values"=>"yes", "mode-region"=>"Not identifiable", "low-values"=>"yes", "very-high-values"=>"yes", "values-distributed-over-gte-four-regions"=>"yes", "values-mostly-in-regions-separated-by-two-regio
ns"=>"yes", "mostly-low-and-marginally-elevated-values"=>"yes", "mostly-low-and-marginally-elevated-values-explanation"=>"", "mostly-high-and-very-high-values"=>"yes", "at-least-twenty-percent-of-values-at-goal"=>"yes", "number-very-high-v
alues-gte-twice-number-at-goal"=>"yes", "values-distributed-between-at-goal-and-marginally-elevated-and-high"=>"yes", "gte-about-half-of-values-at-goal"=>"yes", "almost-all-values-not-at-goal-are-high"=>"yes", "values-distributed-between-a
t-goal-and-high-and-very-high"=>"yes", "very-few-marginally-elevated-values"=>"yes", "explanation-for-high-and-very-high-values"=>"yes"}, "bedtime"=>{"very-low-values"=>"yes", "mode-region"=>"Not identifiable", "low-values"=>"yes", "very-h
igh-values"=>"yes", "values-distributed-over-gte-four-regions"=>"yes", "values-mostly-in-regions-separated-by-two-regions"=>"yes", "mostly-low-and-marginally-elevated-values"=>"yes", "mostly-low-and-marginally-elevated-values-explanation"=
>"Low", "mostly-high-and-very-high-values"=>"yes", "at-least-twenty-percent-of-values-at-goal"=>"yes", "number-very-high-values-gte-twice-number-at-goal"=>"yes", "values-distributed-between-at-goal-and-marginally-elevated-and-high"=>"yes",
"gte-about-half-of-values-at-goal"=>"yes", "almost-all-values-not-at-goal-are-high"=>"yes", "values-distributed-between-at-goal-and-high-and-very-high"=>"yes", "very-few-marginally-elevated-values"=>"yes", "explanation-for-high-and-very-h
igh-values"=>"yes"}, "two-am"=>{"very-low-values"=>"yes", "mode-region"=>"Not identifiable", "low-values"=>"yes", "very-high-values"=>"yes", "values-distributed-over-gte-four-regions"=>"yes", "values-mostly-in-regions-separated-by-two-regi
ons"=>"yes", "mostly-low-and-marginally-elevated-values"=>"yes", "mostly-low-and-marginally-elevated-values-explanation"=>"Low", "mostly-high-and-very-high-values"=>"yes", "at-least-twenty-percent-of-values-at-goal"=>"yes", "number-very-hi
gh-values-gte-twice-number-at-goal"=>"yes", "values-distributed-between-at-goal-and-marginally-elevated-and-high"=>"yes", "gte-about-half-of-values-at-goal"=>"yes", "almost-all-values-not-at-goal-are-high"=>"yes", "values-distributed-betwe
{"utf8"=>"✓", "authenticity_token"=>"VroP3FHDNyxBNNbttFyC05UBt7GRjIxf7R3bd6YoUhY=", "goal-a1c"=>"7", "a1c"=>"7.9", "creatinine"=>"1", "gender"=>"female", "gfr"=>"100", "height-in-in"=>"78", "weight-in-lb"=>"221", "glucose_rec
def params
end
edit params
exit
.ruby --version
--version
help
exit
def mp
end
edit mp
edit-method mp
exit
def params
end
edit params
params
nil.is_a? Hash
[].respond_to?(:[])
"string".to_sym
:test[inside]
@qmtest? = "yep"
@qmtest = "yep"
@qmtest = nil
require "keyword_struct"
Animal = KeywordStruct.new(
  :color,
:name) do
Animal = KeywordStruct.new(
  :color,
  :name,
:other_name) do
  def name
    return @name if @name
      return @other_name if @other_name
      end
    end
spook = Animal.new color: "gray", name: "Spook", other_name: "Little Girl"
spook.name
spook.other_name
spook.instance_variables
spook.instance_variable_get :@name
class Validator
  attr_reader :message, :function
  def initialize message, &function
    @message = message
    @function = function
  end
  def validate *args
    call function, *args
  end
end
evenVal = Validator.new "number must be even", { |n| n % 2 == 0 }
evenVal = Validator.new "number must be even" { |n| n % 2 == 0 }
edit Validator
class Validator
  attr_reader :message, :function
  def initialize message, &function
    @message = message
    @function = function
  end
  def validate *args
    function.call(*args)
  end
end
evenVal = Validator.new "number must be even" { |n| n % 2 == 0 }
evenVal = Validator.new "number must be even", { |n| n % 2 == 0 }
evenVal = Validator.new "number must be even", lambda { |n| n % 2 == 0 }
evenVal = Validator.new "number must be even" { |n| n % 2 == 0 }
evenVal = Validator.new "number must be even", { |n| n % 2 == 0 }
evenVal = Validator.new "number must be even", { |n| n % 2 == 0
}
evenVal = Validator.new("number must be even", { |n| n % 2 == 0 })
evenVal = Validator.new("number must be even", Proc.new { |n| n % 2 == 0 })
evenVal = Validator.new("number must be even", &Proc.new({ |n| n % 2 == 0 }))
evenVal = Validator.new("number must be even", &(Proc.new({ |n| n % 2 == 0 })))
even = Proc.new { |n| n % 2 == 0 }
evenVal = Validator.new "number must be even", &even
evenVal.validate(1)
evenVal.validate(2)
evenVal.validate(0)
evenVal.validate(-1)
evenVal.validate(-2)
evenVal = Validator.new("number must be even", Proc.new { |n| n % 2 == 0 })
class Validator
  attr_reader :message, :function
  def initialize message, function
    @message = message
    @function = function
  end
  def validate *args
    function.call(*args)
  end
end
evenVal = Validator.new("number must be even", Proc.new { |n| n % 2 == 0 })
evenVal.validate(1)
class Validator
  attr_reader :message, :function
  def initialize message, &blk
    @message = message
    @function = blk
  end
  def validate *args
    function.call(*args)
  end
end
evenVal = Validator.new("number must be even") { |n| n % 2 == 0 }
evenVal.validate(1)
evenVal.validate(2)
evenVal.message
class Validation
  attr_reader :message, :validation_function
  def initialize message, &blk
    @message = message
    @validation_function = blk
  end
  def valid? *args
    validation_function.call(*args)
  end
end
class Validator
  attr_reader :validations
  def initialize *validations
    @validations = validations
  end
  def validate obj
    validations.reduce([]) { |errors_acc, v|
      errors_acc << v.message unless v.valid?(obj)
      errors_acc
    }
  end
end
evenVal = Validator.new("number must be even") { |n| n % 2 == 0 }
evenVal = Validation.new("number must be even") { |n| n % 2 == 0 }
numVal = Validation.new("must be numeric") { |o| o.is_a? Numeric }
evenNumber = Validator.new numVal, evenVal
evenNumberValidator = Validator.new numVal, evenVal
evenNumberValidator.validate(0)
evenNumberValidator.validate(1)
evenNumberValidator.validate("dog")
["dog", "is", "happy"].join(",\n")
["dog", "is", "happy"].join(',\n')
["dog", "is", "happy"].join(",\n")
ap ["dog", "is", "happy"].join(",\n")
require "awesome_print"
ap ["dog", "is", "happy"].join(",\n")
puts ["dog", "is", "happy"].join(",\n")
elements = ["dog", "rat", "cat", "hat"]
"#{subject} must be #{elements.map { |e| '"#{e}"' }.join(" or ")}"
subject = "animal"
"#{subject} must be #{elements.map { |e| '"#{e}"' }.join(" or ")}"
element_options = elements.map { |e| "\"#{e}\"" }.join(" or ")
puts element_options
puts "#{subject} must be #{element_options}"
puts "#{subject} must be #{elements.join(" or ")}"
def even? n
  n % 2 == 0
end
evenVal2 = Validation.new("must be an even number", method(:even?))
class Validation
  attr_reader :message, :validation_function
  def initialize message, proc
    @message = message
    @validation_function = proc
  end
  def valid? *args
    validation_function.call(*args)
  end
end
def non_negative_validation? subject
  Validation.new "#{subject} must be a non-negative number", method(:non_negative?)
end
def non_negative? n
  n.is_a?(Numeric) && n >= 0
end
dogVal = non_negative_validation? "dog number"
dogVal(0)
dogVal.validate(0)
dogVal.valid?(0)
dogVal.valid?(-1)
dogVal.valid?(1)
def add a, b
  a + b
end
add1 = add.curry(2)[1]
add1 = method(:add).to_proc.curry(2)[1]
add1(2)
add1[2]
add1[1]
add1.call(1)
add1 = method(:add).to_proc.curry(2).call(1)
add1 = method(:add).curry(2).call(1)
sub = lambda { |a, b| a - b }
sub.call(3, 1)
subtest = sub.curry(2).call(3)
subtest(1)
subtest.call(1)
div = lambda { |n, d| n / d }
div10by = div.curry(2)[10]
div10by[5]
def include? coll, element
  coll.include? element
end
def curry_method meth, arity
  method(meth).to_proc.curry(arity)
end
def in_coll? coll
  -> (el) { curry_method(:include?, 2).call(coll).call(element) }
end
in123 = in_coll? [1, 2, 3]
in123(1)
in123.call(1)
edit in_call?
def in_coll? coll
  -> (el) { curry_method(:include?, 2).call(coll).call(el) }
end
in123.call(1)
in123 = in_coll? [1, 2, 3]
in123.call(1)
in123.call(0)
v = Validation.new "#{subject} must be #{coll.join(" or ")}",
curry_method(:include?, 2).call(coll).call(element)
def element_of_coll_validation subject, *coll
  Validation.new "#{subject} must be #{coll.join(" or ")}",
  curry_method(:include?, 2).call(coll).call(element)
end
v = element_of_coll_validation "dog name", "rick", "mup", "muppet", "squigs", "squiglet", "squiggiggle"
def element_of_coll_validation subject, *coll
  Validation.new "#{subject} must be #{coll.join(" or ")}",
  curry_method(:include?, 2).call(coll)
end
v = element_of_coll_validation "dog name", "rick", "mup", "muppet", "squigs", "squiglet", "squiggiggle"
v.validate "rick"
v.valid? "rick"
v.valid? "ricker"
v.valid? "muppet"
v.valid? "muppettus"
v
v.instance_variable_get :@validation_function
greater_than = -> (x, y) { x > y }
greater_than.call(2, 3)
greater_than.call(4, 3)
lte3 = greater_than.curry(2).call(3)
lte3(4)
lte3.call(4)
lte3.call(3)
lte3.call(2)
lt3 = lte3
lte3 = nil
lt3
lt3.call(3)
lt3.call(2)
[] << "a"
ls Array
ls Enumerable
keys = [1, 2, 3]
#{keys.join(", ")}"
puts "#{keys.join(", ")}"
"#{keys.join(", ")}"
"#{keys.join(', ')}"
puts "#{keys.join(', ')}"
["dog", :muppet, "roosterish dog", :squigs].map { |k| "#{k} (#{k.class})"}.join(", ")
keys_and_their_classes = keys.map { |k|
  return k if k.is_a?(String)
return ":#{k}" if k.is_a?(Symbol)
}.join(", ")
keys = ["dog", :muppet, "roosterish dog", :squigs].map { |k| "#{k} (#{k.class})"}.join(", ")
keys = ["dog", :muppet, "roosterish dog", :squigs]
keys_and_their_classes = keys.map { |k|
  return k if k.is_a?(String)
return ":#{k}" if k.is_a?(Symbol)
}.join(", ")
keys_and_their_classes = keys.map { |k|
  if k.is_a?(String)
    k
  elsif k.is_a?(Symbol)
    ":#{k}" if 
  end
}.join(", ")
keys_and_their_classes = keys.map { |k|
  if k.is_a?(String)
    k
  elsif k.is_a?(Symbol)
    ":#{k}"
  end
}.join(", ")
keys_and_their_classes = keys.map { |k|
  if k.is_a?(String)
    "\"#{k}\""
  elsif k.is_a?(Symbol)
    ":#{k}"
  end
}.join(", ")
puts keys_and_their_classes
key_strings = keys.map { |k|
  if k.is_a?(String)
    ['"', k, '"'].join("")
  elsif k.is_a?(Symbol)
    [":", k].join("")
  end
}.join(", ")
puts key_strings
[
  "a",
  "b",
  *["c", "d", "e"].map { |el| [[el, el]] }
]
[*["c", "d", "e"].map { |el| [[el, el]] }]
[*["c", "d", "e"].flat_map { |el| [[el, el]] }]
[
  "a",
  "b",
  *["c", "d", "e"].flat_map { |el| [[el, el]] }
]
f, *r = [1, 2, 3, 4]
f
r
f, *r = *[1, 2, 3, 4]
f
r
class Validation
  attr_reader :message, :validation_function
  def initialize message, proc
    @message = message
    @validation_function = proc
  end
  def valid? *args
    validation_function.call(*args)
  end
end
def validate_attribute key, validation
  Validation.new validation.message,
  -> (h) { validation.valid?(h[key]) }
end
even
even.call(2)
even.call(1)
evenVal
evenVal2
evenValidator
evenVal2
attr_n_even = validate_attribute :n, evenVal
evenVal(1)
evenVal.valid?(1)
evenVal.valid?(2)
attr_n_even.valid?(1)
attr_n_even.valid?({ m: 1 })
attr_n_even.valid?({ n: 1 })
attr_n_even.valid?({ n: 2 })
attr_n_even.valid?({ n: -22 })
? Enumerable#reduce
[1, 2, 3][:mup]
? rescue
? Kernel.rescue
? Kernel#rescue
ls Kernel
"dog".to_i
"dog".to_r
ls StandardError
ls Exception
def errorTest
def error_test error_type
rescue ArgumentError, NameError, RangeError => e
  p e.message
end
def error_test error_type
  begin
  rescue ArgumentError, NameError, RangeError => e
    p e.message
  end
end
error_test ArgumentError
error_test NameError
error_test RangeError
error_test ArgumentError.new("argument error, son")
ArgumentError.new("argument error, son")
ArgumentError.new("argument error, son").message
error_test NameError.new("name error, son")
error_test RangeError.new("range error, son")
def error_test error_type
  begin
def error_test error
  begin
def error_test error_type, message
  begin
    raise error_type, message
  rescue ArgumentError, NameError, RangeError => e
    p e.message
  end
end
ArgumentError.new("argument error, son").message
error_test NameError.new("name error, son")
error_test ArgumentError, "arg err"
error_test NameError, "name err"
error_test RangeError, "range err"
error_test ZeroDivisionError, "zero div err"
def reduce_test coll
["rat", "cat", "mat"].reduce([]) { |acc, str|
  str[0] == "c" ? acc : acc + [str]
  end
["rat", "cat", "mat"].reduce([]) { |acc, str|
  str[0] == "c" ? acc : acc + [str]
}
["rat", "cat", "mat"].reduce([]) { |acc, str|
  str[0] == "c" ? acc : acc << str
}
edit error_test
error_test ArgumentError, "arg err"
ls Set
? Set#subset?
require "set"
first3 = Set["a", "b", "c"]
first4 = Set["a", "b", "c", "d"]
first3.subset? first4
first4.subset? first3
first3.subset? first3
ZeroDivisionErrorve
ZeroDivisionError
a, b, c = [1, 2, 3]
a
b
c
a
d, e, f = [4, 5, 6]
d
e
f
[1, 2, 3, 4].zip("a")
[1, 2, 3, 4].zip(["a"])
load 'lib/util.rb'
include Util
Util.pipeline(4)
load 'lib/util.rb'
Util.pipeline(4)
Util.pipeline(4, -> (n) { -n })
load 'lib/util.rb'
Util.pipeline(4, -> (n) { -n })
Util.pipeline(4, -> (n) { -n }, -> (n) { n + 1 })
def invert_sign n
  -n
end
Util.pipeline(4, method(:invert_sign))
ls Enumerable
ls Array
[1, 2, 3].second
[1, 2, 3].to_a[1]
Set[1, 2, 3].to_a[1]
Hash[1, 2, 3, 4].to_a[1]
:Util.pipeline
include DmEngine
AtomicDose
load 'lib/dm_engine/values/dose.rb'
load 'lib/dm_engine/values/atomic_dose.rb'
load 'lib/validation.rb'
load 'lib/dm_engine/values/atomic_dose.rb'
exit
load 'lib/validation.rb'
load 'lib/dm_engine/values/dose.rb'
load 'lib/dm_engine/values/atomic_dose.rb'
include DmEngine
ad = Dose.build amount: 6, unit: "dogsworth"
exit
load 'lib/validation.rb'
load 'lib/dm_engine/values/dose.rb'
load 'lib/dm_engine/values/atomic_dose.rb'
ad = Dose.build amount: 6, unit: "dogsworth"
include DmEngine
ad = Dose.build amount: 6, unit: "dogsworth"
ad.atom_denomination
ad.number_of_atoms
"a-dog".camelcase
"a-dog".snakecase
ls String
? String#parameterize
"a-dog".underscore
"a-dog".underscore.to_sym
? String#titlecase
? String#titleize
exit
:dog_happy.split("_")
:dog_happy.to_s.split("_")
["a"].product([[1, 2], [3, 4], [5, 6]])
["a"].product(*[[1, 2], [3, 4], [5, 6]])
["a"].product(*[[[1, 2]], [[3, 4]], [[5, 6]]])
[["a"]].product(*[[[1, 2]], [[3, 4]], [[5, 6]]])
["a"].product([1, 2], [3, 4], [5, 6])
["a"].product([1, 2, 3])
["a"].product(*[[1, 2, 3]])
a, b = [1, 2, 3]
a
b
Animal = Struct.new :type, :size, :name
spook = Animal.new "dog", "little", "Spook"
rick = Animal.new "dog", "small", "Muppet"
frog = Animal.new "frog", "quite small", "frog"
[[spook, rick], frog]
[[spook, rick], frog].flatten
require "nokogiri"
doc = Nokogiri::HTML(open("streams.js"))
doc = Nokogiri::HTML(open("streams.html"))
doc.css("pre")
doc.css("pre").first
doc.css("pre").first.text
doc.css("pre")[1].text
doc.css("pre")[1].text.split("\n")
doc.css("pre")[1].text
doc.css("pre")(0..10)
doc.css("pre").take(10)
doc.css("pre").take(5).reduce("") { |acc_string, node| [acc_string, node.text].join("\n\n\n\n") }
doc = Nokogiri::HTML(open("streams.html"))
pres = doc.css("pre")
exit
case 3
when (0..1) then "between 0 and 1"
when (1..2) then "between 1 and 2"
when (2..3) then "between 2 and 3"
when (3..4) then "between 3 and 4"
end
(0..3).include?(3)
(0...3).include?(3)
case 3
when 2..3 then "between 2 and 3"
end
dogs = { :greatest => "Spook", :nicest => "Spook", :happiest => "Spook", :barkingest => "Rick }
dogs.select { 
dogs = { :greatest => "Spook", :nicest => "Spook", :happiest => "Spook", :barkingest => "Rick" }
dogs.select { |attr, dog_name| dog_name == "Rick" }
load 'lib/dm_engine/values/glucose_record_analysis.rb'
load 'lib/dm_engine/values/timed_glucose_record_analysis.rb'
include DmEngine
gra = GlucoseRecordAnalysis.new fasting: TimedGlucoseRecordAnalysis.new(mode_classification: :high),
noon_meal: TimedGlucoseRecordAnalysis.new(mode_classification: :high),
evening_meal: TimedGlucoseRecordAnalysis.new(mode_classification: :at_goal))
gra = GlucoseRecordAnalysis.new(fasting: TimedGlucoseRecordAnalysis.new(mode_classification: :high),
  noon_meal: TimedGlucoseRecordAnalysis.new(mode_classification: :high),
evening_meal: TimedGlucoseRecordAnalysis.new(mode_classification: :at_goal))
def times_when_high glucose_record_analysis
  glucose_record_analysis.select { |time, timed_glucose_record_analysis|
    timed_glucose_record_analysis.mode_classification == :high
  }
  .map(&:first)
end
def times_when_high glucose_record_analysis
  glucose_record_analysis.select { |time, timed_glucose_record_analysis|
    timed_glucose_record_analysis.mode_classification == :high
  }
  .map(&:first)
end
def times_when_high glucose_record_analysis
  glucose_record_analysis.select { |time, timed_glucose_record_analysis|
    timed_glucose_record_analysis.mode_classification == :high
  }.map(&:first)
end
times_when_high(gra)
def times_when_high glucose_record_analysis
  glucose_record_analysis.select { |time, timed_glucose_record_analysis|
    !timed_glucose_record_analysis.nil? && timed_glucose_record_analysis.mode_classification == :high
  }.map(&:first)
end
times_when_high(gra)
edit times_when_high
times_when_high(gra)
gra
edit times_when_high
Dog = Struct.new :size, :color, :name
spook = Dog.new "little", "gray", "Spook"
spook.select { |k, v| v == "gray" }
spook.select { |k, v| p "k = #{k} and v = #{v}"; true }
def product *colls
  first, *rest = colls
  first.product(*rest)
end
product([[1, 2], [3, 4], [5, 6]])
product([1, 2], [3, 4], [5, 6])
product([1, 2])
[1, 2].product()
[1, 2].product([])
Set[1, 2].subset? [1, 2, 3]
Set[1, 2].subset? Set[1, 2, 3]
Set[1, 2, 3].subset? Set[1, 2]
"non-insulin glucose".underscore
ls String
? String.gsub
? String
? String.gsub
? String#gsub
"non-insulin glucose".gsub(/[-\s]+/, "_")
? String#tr
"non-insulin glucose".gsub(/\s+/, "_").tr("\s", "_")
"non-insulin glucose".gsub(/\s+/, "_").tr("-", "_")
"non-insulin glucose".gsub(/[-\s]+/, "_")
Array(Set[1, 2, 3])
Array(Set[1, 2, 3]).to_set
Array([1, 2, 3]).to_set
Array(1).to_set
Set([1, 2, 3])
def Set obj
  Array(obj).to_set
end
Set([1, 2, 3])
Set(1)
%{string interpolation works in weird-delimited strings? #{true}}
? Array
? Kernel#Array
[[1, 2], [1, 3]].min
ls Array
ls Comparable
ls Enumerable
? Enumerable#min
? Array#<
? Array#<=>
Array(nil)
[nil]
Hash(nil)
Hash({ :name => "Spook", :color => "gray" })
require "keyword_struct"
Animal
Animal.members
Animal.class
Dog = KeywordStruct.new :name, :size, :color
Dog.class
Dog.members
Dog.new name: "Spook", size: "little", color: "gray"
spook = Dog.new name: "Spook", size: "little", color: "gray"
spook.class
spook.class.class
spook.class.class.class
Dog.new name: "Spook", size: "little", color: "gray" do
  def new_with_color new_color
    self.class.new name: name, size: size, color: new_color
  end
end
spook = Dog.new name: "Spook", size: "little", color: "gray"
spook.new_with_color "grayest"
Dog = KeywordStruct.new :name, :size, :color do
  def new_with_color new_color
    self.class.new name: name, size: size, color: new_color
  end
end
spook = Dog.new name: "Spook", size: "little", color: "gray"
spook.new_with_color "grayest"
spook
r_scale = Rational(50.237r, 75)
n_scale = Rational(78.863r, 50)
100.625 * r_scale
49.257 * r_scale
67.4 + 33
exit
100.625 + 49.257
r_hs = Rationale(152, 100.625r + 49.257r)
r_hs = Rational(152, 100.625r + 49.257r)
100.625r * r_hs
(100.625r * r_hs).to_s
(100.625r * r_hs).to_f
(49.257r * r_hs).to_f
n_hs = Rational(376, 200.625r + 174.095r)
(200.625r * n_hs).to_f
(174.095r * n_hs).to_f
600/24
50.237 / 25
102.05 / 25
49.95 / 25
-3*-18.5
55.5 + 45
-3*-13 + 45
(18.5 - 13)*3
def _nm t
  if 9 <= t && t <= 17
3**2
3^2
exit
_n = -> (lin_coef, t) { Rational(3 * (t**2), 16) - lin_coef * t}
_n_low = -> (lin_coef, t) { Rational(3 * (t**2), 16) - lin_coef * t}
_n_low = -> (lin_coef_num, t) { Rational(-3 * (t**2), 16) + Rational(lin_coef_num * t, 8) }
_n_low = -> (lin_coef_num, t) { Rational(3 * (t**2), 16) + Rational(lin_coef_num * t, 8) }
_n_high = -> (lin_coef_num, t) { Rational(-3 * (t**2), 14) + Rational(lin_coef_num * t, 7) }
_r_low = -> (lin_coef, t) { t**2 + lin_coef * t }
_r_high = -> (lin_coef, t) { Rational(-(t**2), 2) + lin_coef * t }
_n_maker = -> (lin_coef_num, low_int, high_int, t) {
  if low_int.include?(t)
    _n_low.curry(2)[lin_coef_num]
  elsif high_int.include?(t)
    _n_high.curry(2)[lin_coef_num]
  end
}
def _nm t
  _n_maker[t]
end
def _nm t
_n_maker = -> (low_coef_num, high_coeff, low_int, high_int, t) {
  if low_int.include?(t)
    _n_low.curry(2)[low_coef_num]
  elsif high_int.include?(t)
    _n_high.curry(2)[high_coeff]
  end
}
def _nm t
(9...17).include?(17)
(9..17).include?(17)
(9..17).include?(16.9)
(9..17).include?(15.998235329)
exit
  _n_maker.call(-27, 72, (9..17), (17..24), t)
end
def _nn t
  _n_maker.call(-39, 84, (13..21), (21..28), t)
end
def _ne t
  _n_maker.call(-55.8, 100.5, (18.5..26.5), (26.5..33.5), t)
end
_r_maker = -> (low_coef, high_coef, low_int, high_int, t) {
  if low_int.include?(t)
    _r_low.curry(2)[low_coef]
  elsif high_int.include?(t)
    _r_high.curry(2)[high_coef]
  end
}
def _rm t
  _r_maker.call(-16, 14, (8..12), (12..14), t)
end
def _rn t
  _r_maker.call(-24, 18, (12..16), (16..18), t)
end
def _re t
  _r_maker.call(-35, 23.5, (17.5..21.5), (21.5..23.5), t)
end
_nm(24) - _nm(17.5)
_nm = -> (t) { _n_maker.call(-27, 72, (9..17), (17..24), t) }
_nn = -> (t) { _n_maker.call(-39, 84, (13..21), (21..28), t) }
_ne = -> (t) { _n_maker.call(-55.8, 100.5, (18.5..26.5), (26.5..33.5), t) }
_rm = -> (t) { _r_maker.call(-16, 14, (8..12), (12..14), t) }
_rn = -> (t) { _r_maker.call(-24, 18, (12..16), (16..18), t) }
_re = -> (t) { _r_maker.call(-35, 23.5, (17.5..21.5), (21.5..23.5), t) }
_nm(24) - _nm(17.5)
_n_maker
_nm = -> (p, t) { p.call(-27, 72, (9..17), (17..24), t) }
_nm = -> (p, t) { p.call(-27, 72, (9..17), (17..24), t) }.curry(2)[_n_maker]
_nn = -> (p, t) { p.call(-39, 84, (13..21), (21..28), t) }.curry(2)[_n_maker]
_ne = -> (p, t) { p.call(-55.8, 100.5, (18.5..26.5), (26.5..33.5), t) }.curry(2)[_n_maker]
_rm = -> (p, t) { p.call(-16, 14, (8..12), (12..14), t) }.curry(2)[_r_maker]
_rn = -> (p, t) { p.call(-24, 18, (12..16), (16..18), t) }.curry(2)[_r_maker]
_re = -> (p, t) { p.call(-35, 23.5, (17.5..21.5), (21.5..23.5), t) }.curry(2)[_r_maker]
_nm(24) - _nm(17.5)
_n_maker
_nm
_nm(1)
nm = -> (p, t) { p.call(-27, 72, (9..17), (17..24), t) }.curry(2)[_n_maker]
_nm(1)
_n_maker
nm = -> (p, t) { p.call(-27, 72, (9..17), (17..24), t) }.curry(2).call(_n_maker)
nm(1)
nm.call(1)
nm[1]
nm[10]
nm[10].call
nm[10].call.call
nm[10].call.call.call
nm[10].call.call.call.call
nm[10].call.call.call.call.call
nm = -> (p, t) { p.call(-27, 72, (9..17), (17..24), t) }.curry(2)[_n_maker]
nm[1]
nm[10]
nm.arity
ls nm
nm.source
-(18**2)/2 + 18*18
-(17.5**2)/2 + 18*17.5
(3 * 18.5**2) / 16 - (55.5 * 18.5) / 8
-(3 * 32**2) / 14 + (100.5 * 32) / 7
-(23.5**2) / 2 + 23.5 * 23.5
17.5**2 - 35 * 17.5
-(21.5**2) / 2 + 23.5 * 21.5
276.125 - 274.125
21.5**2 - 35 * 21.5
-290.25 - -306.25
21.5**2 - 35 * 21.5 - (17.5**2 - 35 * 17.5)
(21.5**2) / 4 - 35 * 21.5 - ((17.5**2) / 4 - 35 * 17.5)
(21.5**2) / 4 - 35 / 4 * 21.5 - ((17.5**2) / 4 - 35 / 4 * 17.5)
17.5 / 2
35 / 4
17.5 * 2
/ 4
35r / 4
(21.5r**2) / 4r - 35r / 4r * 21.5r - ((17.5r**2) / 4r - 35r / 4r * 17.5r)
r = [9.05r, 195.89r, 0.125r, 304.87r, 6r]
sum = r.reduce 0, :+
sum = r.reduce :+
r.map { |n| n / sum }
r.map { |n| (n / sum).to_f }
r.map { |n| (n / sum)*100.to_f }
r.map { |n| (n / sum)*100.round(2).to_f }
r.map { |n| (n / sum)*100.round.to_f }
r.map { |n| (n / sum)*100.to_f.round(2) }
? Float.round
? Float#round
r.map { |n| (n / sum)*100.to_f.round(2) }
r.map { |n| (n / sum)*100.to_f.round }
r.map { |n| ((n / sum)*100.to_f).round(2) }
(3r * 12r**2) / 16r - (27r * 12r) / 8r
-(3r * 24r**2) / 14r + (72r * 24r) / 7r
(-(3r * 24r**2) / 14r + (72r * 24r) / 7r).to_f
-(3r * 17.5r**2) / 14r + (72r * 17.5r) / 7r
(864/7) - (915/8)
-(3r * 28r**2) / 14r + (72r * 28r) / 7r - (-(3r * 21r**2) / 14r + (72r * 21r) / 7r)
(3r * 21r**2) / 16r - (39r * 21r) / 8r - ((3r * 17.5r**2) / 16r - (39r * 17.5r) / 8r)
(525/64).to_f
8*64
-(Rational(3, 7) * -18.5r + Rational(45, 7)
-(Rational(3, 7)) * -18.5r + Rational(45, 7)
201/2.0
-(Rational(3, 7)) * -13r + Rational(45, 7)
-(3r * 28r**2) / 14r + (84r * 28r) / 7r - (-(3r * 21r**2) / 14r + (84r * 21r) / 7r)
(3r * 21r**2) / 16r - (39r * 21r) / 8r - ((3r * 17.5r**2) / 16r - (39r * 17.5r) / 8r)
(21/2) + (525/64)
-(3r * 32r**2) / 14r + (100.5r * 32r) / 7r - (-(3r * 32r**2) / 14r + (100.5r * 32r) / 7r)
-(3r * 32r**2) / 14r + (100.5r * 32r) / 7r - (-(3r * 26.5r**2) / 14r + (100.5r * 26.5r) / 7r)
561/56.0
(3r * 26.5r**2) / 16r - (55.5r * 26.5r) / 8r - ((3r * 18.5r**2) / 16r - (55.5r * 18.5r) / 8r)
Rational(561/56) + 12
Rational(561/56) + 12r
Rational(561/56) + Rational(12, 1)
BigDecimal("561/56") + BigDecimal("12")
require "bigdecimal"
BigDecimal("561/56") + BigDecimal("12")
BigDecimal(Rational(561/56)) + BigDecimal("12")
BigDecimal(Rational(561/56), 30) + BigDecimal("12")
BigDecimal(Rational(561/56), 30) + BigDecimal(12, 30)
1/56.0
1/56.0 + 22
Rational(561/56) + Rational(12, 1)
Rational("561/56") + Rational("12/1")
Rational(561, 56) + Rational(12, 1)
(Rational(561, 56) + Rational(12, 1)).to_f
r = [9, 18, 0.125r, Rational(1233, 56), 6]
sum = r.reduce :+
r.map { |e| (e / sum * 100r).to_f.round(2) }
exit
const_get :Muppet
Object.const_get :Muppet
def test input
  input ? input : raise ArgumentError
def test input
  input ? input : raise(ArgumentError)
rescue ArgumentError
  nil
end
test
def test input = nil
  input ? input : raise(ArgumentError)
rescue ArgumentError
  return nil
end
test
test "dog"
ls Kernel
ls Object
ls BasicObject
Object.ancestors
ls Module
ls Module#const_missing
? Module#const_missing
? Module#const_defined?
exit
ls Hash
? Hash#has_key?
? Hash#key?
$ Hash#key?
$ Hash#has_key?
ls Kernel
ls Module
ls BasicObject
ls Object
? Object#method
Animal
Animal.class
empty_animal = Animal.new
empty_animal.empty?
empty_animal.to_a.empty?
empty_animal.to_a
empty_animal.to_a.compact.empty?
nil.is_a? Numeric
nil.class
"blue" > 0
not true
not(true)
!(true)
ls Object
ls Hash
? Hash#keys
$ Hash#keys
%W("muppet" "jackson")
%Q("muppet" "jackson")
%("muppet" "jackson")
(1..2) + 1
1 + (1..2)
1 + 1..2
1 + 3..8
1 + 3...8
@animals = []
sleep 5
@dogs = []
def get_animals_and_dogs a, d
  t1 = Thread.new do
    %W{ dog cat rat jackson }.each do
      sleep 1
def get_animals_and_dogs a, d
  t1 = Thread.new do
    %W{ dog cat rat jackson }.each do
def get_animals_and_dogs a, d
  t1 = Thread.new do
    %W{ dog cat rat jackson }.each do |animal|
      sleep 1
      a << animal
    end
  end
  t2 = Thread.new do
    %W{ spook ricky max tag }.each do |dog|
      sleep 1
      d << dog
    end
  end
  t1.join
  t2.join
  return a, d
end
get_animals_and_dogs [], []
ri benchmark
require "benchmark"
Benchmark.measure { get_animals_and_dogs [], [] }
edit get_animals_and_dogs
edit-method get_animals_and_dogs
edit get_animals_and_dogs
show get_animals_and_dogs
show_method get_animals_and_dogs
help
show-source get_animals_and_dogs
