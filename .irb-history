a = lambda { |dog| dog.color == "gray" }
a.methods
a.inspect
a.lambda?
a.curry
a.parameters
Animal = Struct.new :type, :color
dog = Animal.new "dog", "gray"
a(dog)
a.call dog
a[dog]
blue_dog = Animal.new "dog", "yellow"
a[blue_dog]
a.call blue_dog
a === Proc
a.source_location
a.singleton_class
a.class
a.singleton_methods
a.display
a
b = lambda { |dog| dog.color == "gray" }
a == b
Set.new(Array(Set.new))
Set.new(Array([]))
Set.new(Array())
Array(nil)
Set.new(Array(nil))
BigDecimal.new("21")/BigDecimal.new("14")
BigDecimal.new("14")/BigDecimal.new("21")
BigDecimal.new("9") * r
Rational.new(1/3) * BigDecimal.new("12")
Rational(1/3) * BigDecimal.new("12")
Rational(1/3)
Rational(1, 3) * BigDecimal.new("12")
-14 % -12
2.5 % 0.1
BigDecimal.new("2.5") % BigDecimal.new("0.1")
r = BigDecimal.new("14")/BigDecimal.new("21")
a = BigDecimal.new("9") * r
BigDecimal.new("9") * BigDecimal.new("14")/BigDecimal.new("21")
require "bigdecimal/math"
BigDecimal.new("9") / BigDecimal.new("21") * BigDecimal.new("14")
(BigDecimal.new("9") / BigDecimal.new("21") * BigDecimal.new("14")).round
(BigDecimal.new("9") / BigDecimal.new("21") * BigDecimal.new("14") / BigDecimal.new("3")).round * BigDecimal.new("3")
((-0.1) / 1).round
((0.1) / 1).round
(BigDecimal.new("0.1") / BigDecimal.new("1")).round
(BigDecimal.new("0.1") / BigDecimal.new("1")).round * BigDecimal.new("1")
3 * BigDecimal.new("1/2")
3 * (BigDecimal.new("1") / BigDecimal.new("3"))
(3 * (BigDecimal.new("1") / BigDecimal.new("3"))).round
(3 * (BigDecimal.new("1") / BigDecimal.new("3"))).round.to_i
(3 * (BigDecimal.new("1") / BigDecimal.new("3"))).round.class
(3 * (BigDecimal.new("1") / BigDecimal.new("3"))).round.to_i.class
(3 * (BigDecimal.new("1") / BigDecimal.new("3"))).round(2)
(3 * (BigDecimal.new("1") / BigDecimal.new("3"))).round(5)
(3 * (BigDecimal.new("1") / BigDecimal.new("3")))
BigDecimal.new("1.111111").round(3)
"1".to_i
load "dm_engine/entities/dosing.rb"
Dose.build(amount: 0, unit: "mg")
Dose.build(amount: 0, unit: "mg").amount
d.atom_denomination
d.atom_denomination.to_s
d.number_of_atoms
d.number_of_atoms.class
d.atom_denomination * d.number_of_atoms
d.amount.method_source
d.methods
ad.atom_denomination
ad.number_of_atoms
ad = AtomicDose.new amount: 0, unit: "mg"
load "dm_engine/entities/atomic_dose.rb"
load "dm_engine/entities/composite_dose.rb"
ad.class
ad.ancestors
ad.class.ancestors
Dose
Dose.amount
ad.methods
load "dm_engine/entities/dose.rb"
Dose.new atom_denomination: "1", number_of_atoms: 3, unit: "foo"
require "bunder/setup"
require "bundler/setup"
require "dm_engine/entities/dose.rb"
require "dm_engine/entities/atomic_dose.rb"
require "dm_engine/entities/composite_dose.rb"
include DmEngine
cd = CompositeDose.new atom_denomination: "1", number_of_atoms: 3, unit: "foo"
cd.amount
d = Dose.new atom_denomination: "1", number_of_atoms: 3, unit: "foo"
ad = AtomicDose.new amount: 1, unit: "mg"
ad.amount
d = Dose.build(amount: 0, unit: "mg")
d.amount
require "set"
Set.new
require "bigdecimal"
exit
